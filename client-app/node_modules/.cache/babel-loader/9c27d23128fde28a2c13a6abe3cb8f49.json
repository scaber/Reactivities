{"ast":null,"code":"// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n// Not exported from index\n\n/** @private */\nvar TextMessageFormat =\n/** @class */\nfunction () {\n  function TextMessageFormat() {}\n\n  TextMessageFormat.write = function (output) {\n    return \"\" + output + TextMessageFormat.RecordSeparator;\n  };\n\n  TextMessageFormat.parse = function (input) {\n    if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\n      throw new Error(\"Message is incomplete.\");\n    }\n\n    var messages = input.split(TextMessageFormat.RecordSeparator);\n    messages.pop();\n    return messages;\n  };\n\n  TextMessageFormat.RecordSeparatorCode = 0x1e;\n  TextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\n  return TextMessageFormat;\n}();\n\nexport { TextMessageFormat };","map":{"version":3,"sources":["../../src/TextMessageFormat.ts"],"names":[],"mappings":"AAAA;AACA;AAEA;;AACA;AACA,IAAA,iBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,iBAAA,GAAA,CAiBC;;AAbiB,EAAA,iBAAA,CAAA,KAAA,GAAd,UAAoB,MAApB,EAAkC;AAC9B,WAAO,KAAG,MAAH,GAAY,iBAAiB,CAAC,eAArC;AACH,GAFa;;AAIA,EAAA,iBAAA,CAAA,KAAA,GAAd,UAAoB,KAApB,EAAiC;AAC7B,QAAI,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAAL,KAA4B,iBAAiB,CAAC,eAAlD,EAAmE;AAC/D,YAAM,IAAI,KAAJ,CAAU,wBAAV,CAAN;AACH;;AAED,QAAM,QAAQ,GAAG,KAAK,CAAC,KAAN,CAAY,iBAAiB,CAAC,eAA9B,CAAjB;AACA,IAAA,QAAQ,CAAC,GAAT;AACA,WAAO,QAAP;AACH,GARa;;AAPA,EAAA,iBAAA,CAAA,mBAAA,GAAsB,IAAtB;AACA,EAAA,iBAAA,CAAA,eAAA,GAAkB,MAAM,CAAC,YAAP,CAAoB,iBAAiB,CAAC,mBAAtC,CAAlB;AAelB,SAAA,iBAAA;AAAC,CAjBD,EAAA;;SAAa,iB","sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// Not exported from index\r\n/** @private */\r\nexport class TextMessageFormat {\r\n    public static RecordSeparatorCode = 0x1e;\r\n    public static RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n\r\n    public static write(output: string): string {\r\n        return `${output}${TextMessageFormat.RecordSeparator}`;\r\n    }\r\n\r\n    public static parse(input: string): string[] {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n\r\n        const messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
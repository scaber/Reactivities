{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v22.1.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Component } from \"../widgets/component\";\nimport { PostConstruct } from \"../context/context\";\nimport { RowNode } from \"../entities/rowNode\";\nimport { DragSourceType } from \"../dragAndDrop/dragAndDropService\";\nimport { Events } from \"../eventKeys\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { _ } from \"../utils\";\n\nvar RowDragComp =\n/** @class */\nfunction (_super) {\n  __extends(RowDragComp, _super);\n\n  function RowDragComp(rowNode, column, cellValue, beans) {\n    var _this = _super.call(this, \"<div class=\\\"ag-row-drag\\\"></div>\") || this;\n\n    _this.rowNode = rowNode;\n    _this.column = column;\n    _this.cellValue = cellValue;\n    _this.beans = beans;\n    return _this;\n  }\n\n  RowDragComp.prototype.postConstruct = function () {\n    var eGui = this.getGui();\n    eGui.appendChild(_.createIconNoSpan('rowDrag', this.beans.gridOptionsWrapper, null));\n    this.addDragSource();\n    this.checkCompatibility();\n    var strategy = this.beans.gridOptionsWrapper.isRowDragManaged() ? new ManagedVisibilityStrategy(this, this.beans, this.rowNode, this.column) : new NonManagedVisibilityStrategy(this, this.beans, this.rowNode, this.column);\n    this.addFeature(strategy, this.beans.context);\n  }; // returns true if all compatibility items work out\n\n\n  RowDragComp.prototype.checkCompatibility = function () {\n    var managed = this.beans.gridOptionsWrapper.isRowDragManaged();\n    var treeData = this.beans.gridOptionsWrapper.isTreeData();\n\n    if (treeData && managed) {\n      _.doOnce(function () {\n        return console.warn('ag-Grid: If using row drag with tree data, you cannot have rowDragManaged=true');\n      }, 'RowDragComp.managedAndTreeData');\n    }\n  };\n\n  RowDragComp.prototype.addDragSource = function () {\n    var _this = this;\n\n    var dragItem = {\n      rowNode: this.rowNode\n    };\n    var dragSource = {\n      type: DragSourceType.RowDrag,\n      eElement: this.getGui(),\n      dragItemName: this.cellValue,\n      getDragItem: function () {\n        return dragItem;\n      },\n      dragStartPixels: 0\n    };\n    this.beans.dragAndDropService.addDragSource(dragSource, true);\n    this.addDestroyFunc(function () {\n      return _this.beans.dragAndDropService.removeDragSource(dragSource);\n    });\n  };\n\n  __decorate([PostConstruct], RowDragComp.prototype, \"postConstruct\", null);\n\n  return RowDragComp;\n}(Component);\n\nexport { RowDragComp };\n\nvar VisibilityStrategy =\n/** @class */\nfunction (_super) {\n  __extends(VisibilityStrategy, _super);\n\n  function VisibilityStrategy(parent, rowNode, column) {\n    var _this = _super.call(this) || this;\n\n    _this.parent = parent;\n    _this.column = column;\n    _this.rowNode = rowNode;\n    return _this;\n  }\n\n  VisibilityStrategy.prototype.setDisplayedOrVisible = function (neverDisplayed) {\n    if (neverDisplayed) {\n      this.parent.setDisplayed(false);\n    } else {\n      var shown = this.column.isRowDrag(this.rowNode);\n\n      var isShownSometimes = _.isFunction(this.column.getColDef().rowDrag); // if shown sometimes, them some rows can have drag handle while other don't,\n      // so we use setVisible to keep the handles horizontally aligned (as setVisible\n      // keeps the empty space, whereas setDisplayed looses the space)\n\n\n      if (isShownSometimes) {\n        this.parent.setDisplayed(true);\n        this.parent.setVisible(shown);\n      } else {\n        this.parent.setDisplayed(shown);\n      }\n    }\n  };\n\n  return VisibilityStrategy;\n}(BeanStub); // when non managed, the visibility depends on suppressRowDrag property only\n\n\nvar NonManagedVisibilityStrategy =\n/** @class */\nfunction (_super) {\n  __extends(NonManagedVisibilityStrategy, _super);\n\n  function NonManagedVisibilityStrategy(parent, beans, rowNode, column) {\n    var _this = _super.call(this, parent, rowNode, column) || this;\n\n    _this.beans = beans;\n    return _this;\n  }\n\n  NonManagedVisibilityStrategy.prototype.postConstruct = function () {\n    this.addDestroyableEventListener(this.beans.gridOptionsWrapper, 'suppressRowDrag', this.onSuppressRowDrag.bind(this)); // in case data changes, then we need to update visibility of drag item\n\n    this.addDestroyableEventListener(this.rowNode, RowNode.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this));\n    this.addDestroyableEventListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this));\n    this.workOutVisibility();\n  };\n\n  NonManagedVisibilityStrategy.prototype.onSuppressRowDrag = function () {\n    this.workOutVisibility();\n  };\n\n  NonManagedVisibilityStrategy.prototype.workOutVisibility = function () {\n    // only show the drag if both sort and filter are not present\n    var neverDisplayed = this.beans.gridOptionsWrapper.isSuppressRowDrag();\n    this.setDisplayedOrVisible(neverDisplayed);\n  };\n\n  __decorate([PostConstruct], NonManagedVisibilityStrategy.prototype, \"postConstruct\", null);\n\n  return NonManagedVisibilityStrategy;\n}(VisibilityStrategy); // when managed, the visibility depends on sort, filter and row group, as well as suppressRowDrag property\n\n\nvar ManagedVisibilityStrategy =\n/** @class */\nfunction (_super) {\n  __extends(ManagedVisibilityStrategy, _super);\n\n  function ManagedVisibilityStrategy(parent, beans, rowNode, column) {\n    var _this = _super.call(this, parent, rowNode, column) || this;\n\n    _this.beans = beans;\n    return _this;\n  }\n\n  ManagedVisibilityStrategy.prototype.postConstruct = function () {\n    // we do not show the component if sort, filter or grouping is active\n    this.addDestroyableEventListener(this.beans.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n    this.addDestroyableEventListener(this.beans.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n    this.addDestroyableEventListener(this.beans.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onRowGroupChanged.bind(this)); // in case data changes, then we need to update visibility of drag item\n\n    this.addDestroyableEventListener(this.rowNode, RowNode.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this));\n    this.addDestroyableEventListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this));\n    this.addDestroyableEventListener(this.beans.gridOptionsWrapper, 'suppressRowDrag', this.onSuppressRowDrag.bind(this));\n    this.updateSortActive();\n    this.updateFilterActive();\n    this.updateRowGroupActive();\n    this.workOutVisibility();\n  };\n\n  ManagedVisibilityStrategy.prototype.updateRowGroupActive = function () {\n    var rowGroups = this.beans.columnController.getRowGroupColumns();\n    this.rowGroupActive = !_.missingOrEmpty(rowGroups);\n  };\n\n  ManagedVisibilityStrategy.prototype.onRowGroupChanged = function () {\n    this.updateRowGroupActive();\n    this.workOutVisibility();\n  };\n\n  ManagedVisibilityStrategy.prototype.updateSortActive = function () {\n    var sortModel = this.beans.sortController.getSortModel();\n    this.sortActive = !_.missingOrEmpty(sortModel);\n  };\n\n  ManagedVisibilityStrategy.prototype.onSortChanged = function () {\n    this.updateSortActive();\n    this.workOutVisibility();\n  };\n\n  ManagedVisibilityStrategy.prototype.updateFilterActive = function () {\n    this.filterActive = this.beans.filterManager.isAnyFilterPresent();\n  };\n\n  ManagedVisibilityStrategy.prototype.onFilterChanged = function () {\n    this.updateFilterActive();\n    this.workOutVisibility();\n  };\n\n  ManagedVisibilityStrategy.prototype.onSuppressRowDrag = function () {\n    this.workOutVisibility();\n  };\n\n  ManagedVisibilityStrategy.prototype.workOutVisibility = function () {\n    // only show the drag if both sort and filter are not present\n    var sortOrFilterOrGroupActive = this.sortActive || this.filterActive || this.rowGroupActive;\n    var suppressRowDrag = this.beans.gridOptionsWrapper.isSuppressRowDrag();\n    var neverDisplayed = sortOrFilterOrGroupActive || suppressRowDrag;\n    this.setDisplayedOrVisible(neverDisplayed);\n  };\n\n  __decorate([PostConstruct], ManagedVisibilityStrategy.prototype, \"postConstruct\", null);\n\n  return ManagedVisibilityStrategy;\n}(VisibilityStrategy);","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v22.1.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { Bean } from \"./context/context\";\nimport { Qualifier } from \"./context/context\";\n\nvar EventService =\n/** @class */\nfunction () {\n  function EventService() {\n    this.allSyncListeners = new Map();\n    this.allAsyncListeners = new Map();\n    this.globalSyncListeners = new Set();\n    this.globalAsyncListeners = new Set();\n    this.asyncFunctionsQueue = [];\n    this.scheduled = false; // using an object performs better than a Set for the number of different events we have\n\n    this.firedEvents = {};\n  }\n\n  EventService_1 = EventService; // because this class is used both inside the context and outside the context, we do not\n  // use autowired attributes, as that would be confusing, as sometimes the attributes\n  // would be wired, and sometimes not.\n  //\n  // the global event servers used by ag-Grid is autowired by the context once, and this\n  // setBeans method gets called once.\n  //\n  // the times when this class is used outside of the context (eg RowNode has an instance of this\n  // class) then it is not a bean, and this setBeans method is not called.\n\n  EventService.prototype.setBeans = function (loggerFactory, gridOptionsWrapper, globalEventListener) {\n    if (globalEventListener === void 0) {\n      globalEventListener = null;\n    }\n\n    this.logger = loggerFactory.create('EventService');\n\n    if (globalEventListener) {\n      var async = gridOptionsWrapper.useAsyncEvents();\n      this.addGlobalListener(globalEventListener, async);\n    }\n  };\n\n  EventService.prototype.getListeners = function (eventType, async) {\n    var listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;\n    var listeners = listenerMap.get(eventType);\n\n    if (!listeners) {\n      listeners = new Set();\n      listenerMap.set(eventType, listeners);\n    }\n\n    return listeners;\n  };\n\n  EventService.prototype.addEventListener = function (eventType, listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    this.getListeners(eventType, async).add(listener);\n  };\n\n  EventService.prototype.removeEventListener = function (eventType, listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    this.getListeners(eventType, async).delete(listener);\n  }; // for some events, it's important that the model gets to hear about them before the view,\n  // as the model may need to update before the view works on the info. if you register\n  // via this method, you get notified before the view parts\n\n\n  EventService.prototype.addModalPriorityEventListener = function (eventType, listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    this.addEventListener(eventType + EventService_1.PRIORITY, listener, async);\n  };\n\n  EventService.prototype.addGlobalListener = function (listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    (async ? this.globalAsyncListeners : this.globalSyncListeners).add(listener);\n  };\n\n  EventService.prototype.removeGlobalListener = function (listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    (async ? this.globalAsyncListeners : this.globalSyncListeners).delete(listener);\n  };\n\n  EventService.prototype.dispatchEvent = function (event) {\n    this.dispatchToListeners(event, true);\n    this.dispatchToListeners(event, false);\n    this.firedEvents[event.type] = true;\n  };\n\n  EventService.prototype.dispatchEventOnce = function (event) {\n    if (!this.firedEvents[event.type]) {\n      this.dispatchEvent(event);\n    }\n  };\n\n  EventService.prototype.dispatchToListeners = function (event, async) {\n    var _this = this;\n\n    var eventType = event.type;\n\n    var processEventListeners = function (listeners) {\n      return listeners.forEach(function (listener) {\n        if (async) {\n          _this.dispatchAsync(function () {\n            return listener(event);\n          });\n        } else {\n          listener(event);\n        }\n      });\n    }; // PRIORITY events should be processed first\n\n\n    processEventListeners(this.getListeners(eventType + EventService_1.PRIORITY, async));\n    processEventListeners(this.getListeners(eventType, async));\n    var globalListeners = async ? this.globalAsyncListeners : this.globalSyncListeners;\n    globalListeners.forEach(function (listener) {\n      if (async) {\n        _this.dispatchAsync(function () {\n          return listener(eventType, event);\n        });\n      } else {\n        listener(eventType, event);\n      }\n    });\n  }; // this gets called inside the grid's thread, for each event that it\n  // wants to set async. the grid then batches the events into one setTimeout()\n  // because setTimeout() is an expensive operation. ideally we would have\n  // each event in it's own setTimeout(), but we batch for performance.\n\n\n  EventService.prototype.dispatchAsync = function (func) {\n    // add to the queue for executing later in the next VM turn\n    this.asyncFunctionsQueue.push(func); // check if timeout is already scheduled. the first time the grid calls\n    // this within it's thread turn, this should be false, so it will schedule\n    // the 'flush queue' method the first time it comes here. then the flag is\n    // set to 'true' so it will know it's already scheduled for subsequent calls.\n\n    if (!this.scheduled) {\n      // if not scheduled, schedule one\n      window.setTimeout(this.flushAsyncQueue.bind(this), 0); // mark that it is scheduled\n\n      this.scheduled = true;\n    }\n  }; // this happens in the next VM turn only, and empties the queue of events\n\n\n  EventService.prototype.flushAsyncQueue = function () {\n    this.scheduled = false; // we take a copy, because the event listener could be using\n    // the grid, which would cause more events, which would be potentially\n    // added to the queue, so safe to take a copy, the new events will\n    // get executed in a later VM turn rather than risk updating the\n    // queue as we are flushing it.\n\n    var queueCopy = this.asyncFunctionsQueue.slice();\n    this.asyncFunctionsQueue = []; // execute the queue\n\n    queueCopy.forEach(function (func) {\n      return func();\n    });\n  };\n\n  var EventService_1; // this is an old idea niall had, should really take it out, was to do with ordering who gets to process\n  // events first, to give model and service objects preference over the view\n\n  EventService.PRIORITY = '-P1';\n\n  __decorate([__param(0, Qualifier('loggerFactory')), __param(1, Qualifier('gridOptionsWrapper')), __param(2, Qualifier('globalEventListener'))], EventService.prototype, \"setBeans\", null);\n\n  EventService = EventService_1 = __decorate([Bean('eventService')], EventService);\n  return EventService;\n}();\n\nexport { EventService };","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _filter = require(\"ol/format/filter\");\n\nvar _WFS = _interopRequireDefault(require(\"ol/format/WFS\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * Helper class for building filters to be used with WFS GetFeature requests.\n *\n * @class WfsFilterUtil\n */\n\n\nvar WfsFilterUtil =\n/*#__PURE__*/\nfunction () {\n  function WfsFilterUtil() {\n    _classCallCheck(this, WfsFilterUtil);\n  }\n\n  _createClass(WfsFilterUtil, null, [{\n    key: \"createWfsFilter\",\n\n    /**\n     * Creates a filter for a given feature type considering configured\n     * search attributes, mapped features types to an array of attribute details and the\n     * current search term.\n     * Currently supports EQUALTO and LIKE filters only, which can be combined with\n     * OR filter if searchAttributes array contains multiple values though.\n     *\n     * @param {string} featureType Name of feature type to be used in filter.\n     * @param {string} searchTerm Search value.\n     * @param {Object} searchAttributes An object mapping feature types to an array of\n     *   attributes that should be searched through.\n     * @param {Object} attributeDetails An object mapping feature types to an\n     *   array of attribute details.\n     * @return {OlFormatFilter} Filter to be used with WFS GetFeature requests.\n     * @private\n     */\n    value: function createWfsFilter(featureType, searchTerm, searchAttributes, attributeDetails) {\n      var attributes = searchAttributes && searchAttributes[featureType];\n\n      if (!attributes) {\n        return null;\n      }\n\n      var details = attributeDetails && attributeDetails[featureType];\n      var propertyFilters = attributes.map(function (attribute) {\n        var filterDetails = details && details[attribute];\n\n        if (filterDetails) {\n          var type = filterDetails.type;\n\n          if (type && (type === 'int' || type === 'number') && searchTerm.match(/[^.\\d]/)) {\n            return undefined;\n          }\n\n          if (filterDetails.exactSearch) {\n            return (0, _filter.equalTo)(attribute, searchTerm, filterDetails.exactSearch);\n          } else {\n            return (0, _filter.like)(attribute, \"*\".concat(searchTerm, \"*\"), '*', '.', '!', filterDetails.matchCase || false);\n          }\n        } else {\n          return (0, _filter.like)(attribute, \"*\".concat(searchTerm, \"*\"), '*', '.', '!', false);\n        }\n      }).filter(function (filter) {\n        return filter !== undefined;\n      });\n\n      if (attributes.length > 1 && Object.keys(propertyFilters).length > 1) {\n        return _filter.or.apply(void 0, _toConsumableArray(propertyFilters));\n      } else {\n        return propertyFilters[0];\n      }\n    }\n    /**\n     * Creates GetFeature request body for all provided featureTypes and\n     * applies related filter encoding on it.\n     *\n     * @param {Object} searchOpts Search options object which has the following\n     * keys (see also https://github.com/terrestris/react-geo/blob/master/src/Field/WfsSearch/\n     * for further options explanations and examples):\n     *   * featureNS        {String}   The namespace URI used for features\n     *   * featurePrefix    {String}   The prefix for the feature namespace.\n     *   * featureTypes     {String[]} The feature type names to search through.\n     *   * geometryName     {String}   Geometry name to use in a BBOX filter.\n     *   * maxFeatures      {Number}   Maximum number of features to fetch.\n     *   * outputFormat     {String}   The output format of the response.\n     *   * propertyNames    {String[]} Optional list of property names to serialize.\n     *   * srsName          {String}   SRS name.\n     *   * wfsFormatOptions {Object}   Options which are passed to the constructor of the ol.format.WFS\n     *                                 (compare: https://openlayers.org/en/latest/apidoc/ol.format.WFS.html)\n     *   * searchAttributes {Object}   An object mapping feature types to an array\n     *                                 of attributes that should be searched through.\n     *   * attributeDetails {Object}   A nested object mapping feature types to an\n     *                                 object of attribute details, which are also\n     *                                 mapped by search attribute name.\n     * @param {string} searchTerm Search string to be used with filter.\n     */\n\n  }, {\n    key: \"getCombinedRequests\",\n    value: function getCombinedRequests(searchOpts, searchTerm) {\n      var featureNS = searchOpts.featureNS,\n          featurePrefix = searchOpts.featurePrefix,\n          featureTypes = searchOpts.featureTypes,\n          geometryName = searchOpts.geometryName,\n          maxFeatures = searchOpts.maxFeatures,\n          outputFormat = searchOpts.outputFormat,\n          propertyNames = searchOpts.propertyNames,\n          srsName = searchOpts.srsName,\n          wfsFormatOptions = searchOpts.wfsFormatOptions,\n          searchAttributes = searchOpts.searchAttributes,\n          attributeDetails = searchOpts.attributeDetails;\n      var requests = featureTypes.map(function (featureType) {\n        var filter = WfsFilterUtil.createWfsFilter(featureType, searchTerm, searchAttributes, attributeDetails);\n        var options = {\n          featureNS: featureNS,\n          featurePrefix: featurePrefix,\n          featureTypes: [featureType],\n          geometryName: geometryName,\n          maxFeatures: maxFeatures,\n          outputFormat: outputFormat,\n          propertyNames: propertyNames,\n          srsName: srsName,\n          filter: filter\n        };\n        var wfsFormat = new _WFS[\"default\"](wfsFormatOptions);\n        return wfsFormat.writeGetFeature(options);\n      });\n      var request = requests[0];\n      requests.forEach(function (req) {\n        if (req !== request) {\n          var query = req.querySelector('Query');\n          request.append(query);\n        }\n      });\n      return request;\n    }\n  }]);\n\n  return WfsFilterUtil;\n}();\n\nvar _default = WfsFilterUtil;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}
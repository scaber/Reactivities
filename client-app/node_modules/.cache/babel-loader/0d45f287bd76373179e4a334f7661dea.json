{"ast":null,"code":"// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { LogLevel } from \"./ILogger\";\nimport { NullLogger } from \"./Loggers\";\n/** @private */\n\nvar Arg =\n/** @class */\nfunction () {\n  function Arg() {}\n\n  Arg.isRequired = function (val, name) {\n    if (val === null || val === undefined) {\n      throw new Error(\"The '\" + name + \"' argument is required.\");\n    }\n  };\n\n  Arg.isIn = function (val, values, name) {\n    // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\n    if (!(val in values)) {\n      throw new Error(\"Unknown \" + name + \" value: \" + val + \".\");\n    }\n  };\n\n  return Arg;\n}();\n\nexport { Arg };\n/** @private */\n\nexport function getDataDetail(data, includeContent) {\n  var detail = \"\";\n\n  if (isArrayBuffer(data)) {\n    detail = \"Binary data of length \" + data.byteLength;\n\n    if (includeContent) {\n      detail += \". Content: '\" + formatArrayBuffer(data) + \"'\";\n    }\n  } else if (typeof data === \"string\") {\n    detail = \"String data of length \" + data.length;\n\n    if (includeContent) {\n      detail += \". Content: '\" + data + \"'\";\n    }\n  }\n\n  return detail;\n}\n/** @private */\n\nexport function formatArrayBuffer(data) {\n  var view = new Uint8Array(data); // Uint8Array.map only supports returning another Uint8Array?\n\n  var str = \"\";\n  view.forEach(function (num) {\n    var pad = num < 16 ? \"0\" : \"\";\n    str += \"0x\" + pad + num.toString(16) + \" \";\n  }); // Trim of trailing space.\n\n  return str.substr(0, str.length - 1);\n} // Also in signalr-protocol-msgpack/Utils.ts\n\n/** @private */\n\nexport function isArrayBuffer(val) {\n  return val && typeof ArrayBuffer !== \"undefined\" && (val instanceof ArrayBuffer || // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\n  val.constructor && val.constructor.name === \"ArrayBuffer\");\n}\n/** @private */\n\nexport function sendMessage(logger, transportName, httpClient, url, accessTokenFactory, content, logMessageContent) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, headers, token, responseType, response;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          if (!accessTokenFactory) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , accessTokenFactory()];\n\n        case 1:\n          token = _b.sent();\n\n          if (token) {\n            headers = (_a = {}, _a[\"Authorization\"] = \"Bearer \" + token, _a);\n          }\n\n          _b.label = 2;\n\n        case 2:\n          logger.log(LogLevel.Trace, \"(\" + transportName + \" transport) sending data. \" + getDataDetail(content, logMessageContent) + \".\");\n          responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\n          return [4\n          /*yield*/\n          , httpClient.post(url, {\n            content: content,\n            headers: headers,\n            responseType: responseType\n          })];\n\n        case 3:\n          response = _b.sent();\n          logger.log(LogLevel.Trace, \"(\" + transportName + \" transport) request complete. Response status: \" + response.statusCode + \".\");\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n/** @private */\n\nexport function createLogger(logger) {\n  if (logger === undefined) {\n    return new ConsoleLogger(LogLevel.Information);\n  }\n\n  if (logger === null) {\n    return NullLogger.instance;\n  }\n\n  if (logger.log) {\n    return logger;\n  }\n\n  return new ConsoleLogger(logger);\n}\n/** @private */\n\nvar Subject =\n/** @class */\nfunction () {\n  function Subject() {\n    this.observers = [];\n  }\n\n  Subject.prototype.next = function (item) {\n    for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\n      var observer = _a[_i];\n      observer.next(item);\n    }\n  };\n\n  Subject.prototype.error = function (err) {\n    for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\n      var observer = _a[_i];\n\n      if (observer.error) {\n        observer.error(err);\n      }\n    }\n  };\n\n  Subject.prototype.complete = function () {\n    for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\n      var observer = _a[_i];\n\n      if (observer.complete) {\n        observer.complete();\n      }\n    }\n  };\n\n  Subject.prototype.subscribe = function (observer) {\n    this.observers.push(observer);\n    return new SubjectSubscription(this, observer);\n  };\n\n  return Subject;\n}();\n\nexport { Subject };\n/** @private */\n\nvar SubjectSubscription =\n/** @class */\nfunction () {\n  function SubjectSubscription(subject, observer) {\n    this.subject = subject;\n    this.observer = observer;\n  }\n\n  SubjectSubscription.prototype.dispose = function () {\n    var index = this.subject.observers.indexOf(this.observer);\n\n    if (index > -1) {\n      this.subject.observers.splice(index, 1);\n    }\n\n    if (this.subject.observers.length === 0 && this.subject.cancelCallback) {\n      this.subject.cancelCallback().catch(function (_) {});\n    }\n  };\n\n  return SubjectSubscription;\n}();\n\nexport { SubjectSubscription };\n/** @private */\n\nvar ConsoleLogger =\n/** @class */\nfunction () {\n  function ConsoleLogger(minimumLogLevel) {\n    this.minimumLogLevel = minimumLogLevel;\n  }\n\n  ConsoleLogger.prototype.log = function (logLevel, message) {\n    if (logLevel >= this.minimumLogLevel) {\n      switch (logLevel) {\n        case LogLevel.Critical:\n        case LogLevel.Error:\n          console.error(\"[\" + new Date().toISOString() + \"] \" + LogLevel[logLevel] + \": \" + message);\n          break;\n\n        case LogLevel.Warning:\n          console.warn(\"[\" + new Date().toISOString() + \"] \" + LogLevel[logLevel] + \": \" + message);\n          break;\n\n        case LogLevel.Information:\n          console.info(\"[\" + new Date().toISOString() + \"] \" + LogLevel[logLevel] + \": \" + message);\n          break;\n\n        default:\n          // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\n          console.log(\"[\" + new Date().toISOString() + \"] \" + LogLevel[logLevel] + \": \" + message);\n          break;\n      }\n    }\n  };\n\n  return ConsoleLogger;\n}();\n\nexport { ConsoleLogger };","map":{"version":3,"sources":["../../src/Utils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { IStreamResult, IStreamSubscriber, ISubscription } from \"./Stream\";\r\n\r\n/** @private */\r\nexport class Arg {\r\n    public static isRequired(val: any, name: string): void {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(`The '${name}' argument is required.`);\r\n        }\r\n    }\r\n\r\n    public static isIn(val: any, values: any, name: string): void {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(`Unknown ${name} value: ${val}.`);\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getDataDetail(data: any, includeContent: boolean): string {\r\n    let detail = \"\";\r\n    if (isArrayBuffer(data)) {\r\n        detail = `Binary data of length ${data.byteLength}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${formatArrayBuffer(data)}'`;\r\n        }\r\n    } else if (typeof data === \"string\") {\r\n        detail = `String data of length ${data.length}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${data}'`;\r\n        }\r\n    }\r\n    return detail;\r\n}\r\n\r\n/** @private */\r\nexport function formatArrayBuffer(data: ArrayBuffer): string {\r\n    const view = new Uint8Array(data);\r\n\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    let str = \"\";\r\n    view.forEach((num) => {\r\n        const pad = num < 16 ? \"0\" : \"\";\r\n        str += `0x${pad}${num.toString(16)} `;\r\n    });\r\n\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\n\r\n// Also in signalr-protocol-msgpack/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n        // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n        (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n\r\n/** @private */\r\nexport async function sendMessage(logger: ILogger, transportName: string, httpClient: HttpClient, url: string, accessTokenFactory: (() => string | Promise<string>) | undefined, content: string | ArrayBuffer, logMessageContent: boolean): Promise<void> {\r\n    let headers;\r\n    if (accessTokenFactory) {\r\n        const token = await accessTokenFactory();\r\n        if (token) {\r\n            headers = {\r\n                [\"Authorization\"]: `Bearer ${token}`,\r\n            };\r\n        }\r\n    }\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, logMessageContent)}.`);\r\n\r\n    const responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\r\n    const response = await httpClient.post(url, {\r\n        content,\r\n        headers,\r\n        responseType,\r\n    });\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\r\n}\r\n\r\n/** @private */\r\nexport function createLogger(logger?: ILogger | LogLevel) {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(LogLevel.Information);\r\n    }\r\n\r\n    if (logger === null) {\r\n        return NullLogger.instance;\r\n    }\r\n\r\n    if ((logger as ILogger).log) {\r\n        return logger as ILogger;\r\n    }\r\n\r\n    return new ConsoleLogger(logger as LogLevel);\r\n}\r\n\r\n/** @private */\r\nexport class Subject<T> implements IStreamResult<T> {\r\n    public observers: Array<IStreamSubscriber<T>>;\r\n    public cancelCallback?: () => Promise<void>;\r\n\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n\r\n    public next(item: T): void {\r\n        for (const observer of this.observers) {\r\n            observer.next(item);\r\n        }\r\n    }\r\n\r\n    public error(err: any): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    }\r\n\r\n    public complete(): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    }\r\n\r\n    public subscribe(observer: IStreamSubscriber<T>): ISubscription<T> {\r\n        this.observers.push(observer);\r\n        return new SubjectSubscription(this, observer);\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class SubjectSubscription<T> implements ISubscription<T> {\r\n    private subject: Subject<T>;\r\n    private observer: IStreamSubscriber<T>;\r\n\r\n    constructor(subject: Subject<T>, observer: IStreamSubscriber<T>) {\r\n        this.subject = subject;\r\n        this.observer = observer;\r\n    }\r\n\r\n    public dispose(): void {\r\n        const index: number = this.subject.observers.indexOf(this.observer);\r\n        if (index > -1) {\r\n            this.subject.observers.splice(index, 1);\r\n        }\r\n\r\n        if (this.subject.observers.length === 0 && this.subject.cancelCallback) {\r\n            this.subject.cancelCallback().catch((_) => { });\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class ConsoleLogger implements ILogger {\r\n    private readonly minimumLogLevel: LogLevel;\r\n\r\n    constructor(minimumLogLevel: LogLevel) {\r\n        this.minimumLogLevel = minimumLogLevel;\r\n    }\r\n\r\n    public log(logLevel: LogLevel, message: string): void {\r\n        if (logLevel >= this.minimumLogLevel) {\r\n            switch (logLevel) {\r\n                case LogLevel.Critical:\r\n                case LogLevel.Error:\r\n                    console.error(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n                case LogLevel.Warning:\r\n                    console.warn(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n                case LogLevel.Information:\r\n                    console.info(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    console.log(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
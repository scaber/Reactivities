{"ast":null,"code":"import { D2R, R2D, PJD_3PARAM, PJD_7PARAM } from './constants/values';\nimport datum_transform from './datum_transform';\nimport adjust_axis from './adjust_axis';\nimport proj from './Proj';\nimport toPoint from './common/toPoint';\nimport checkSanity from './checkSanity';\n\nfunction checkNotWGS(source, dest) {\n  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84' || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84';\n}\n\nexport default function transform(source, dest, point) {\n  var wgs84;\n\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n\n  checkSanity(point); // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point);\n    source = wgs84;\n  } // DGR, 2010/11/12\n\n\n  if (source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  } // Transform source points to long/lat, if they aren't already.\n\n\n  if (source.projName === 'longlat') {\n    point = {\n      x: point.x * D2R,\n      y: point.y * D2R,\n      z: point.z || 0\n    };\n  } else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter,\n        z: point.z || 0\n      };\n    }\n\n    point = source.inverse(point); // Convert Cartesian to longlat\n  } // Adjust for the prime meridian if necessary\n\n\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  } // Convert datums if needed, and if possible.\n\n\n  point = datum_transform(source.datum, dest.datum, point); // Adjust for the prime meridian if necessary\n\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.from_greenwich,\n      y: point.y,\n      z: point.z || 0\n    };\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D,\n      z: point.z || 0\n    };\n  } else {\n    // else project\n    point = dest.forward(point);\n\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter,\n        z: point.z || 0\n      };\n    }\n  } // DGR, 2010/11/12\n\n\n  if (dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n\n  return point;\n}","map":null,"metadata":{},"sourceType":"module"}
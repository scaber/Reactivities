{"ast":null,"code":"'use strict';\n\nfunction isClockWise(array) {\n  var sum = 0;\n  var i = 1;\n  var len = array.length;\n  var prev, cur;\n\n  while (i < len) {\n    prev = cur || array[0];\n    cur = array[i];\n    sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);\n    i++;\n  }\n\n  return sum > 0;\n}\n\nfunction polyReduce(a, b) {\n  if (isClockWise(b) || !a.length) {\n    a.push([b]);\n  } else {\n    a[a.length - 1].push(b);\n  }\n\n  return a;\n}\n\nParseShp.prototype.parsePoint = function (data) {\n  return {\n    'type': 'Point',\n    'coordinates': this.parseCoord(data, 0)\n  };\n};\n\nParseShp.prototype.parseZPoint = function (data) {\n  var pointXY = this.parsePoint(data);\n  pointXY.coordinates.push(data.readDoubleLE(16));\n  return pointXY;\n};\n\nParseShp.prototype.parsePointArray = function (data, offset, num) {\n  var out = [];\n  var done = 0;\n\n  while (done < num) {\n    out.push(this.parseCoord(data, offset));\n    offset += 16;\n    done++;\n  }\n\n  return out;\n};\n\nParseShp.prototype.parseZPointArray = function (data, zOffset, num, coordinates) {\n  var i = 0;\n\n  while (i < num) {\n    coordinates[i].push(data.readDoubleLE(zOffset));\n    i++;\n    zOffset += 8;\n  }\n\n  return coordinates;\n};\n\nParseShp.prototype.parseArrayGroup = function (data, offset, partOffset, num, tot) {\n  var out = [];\n  var done = 0;\n  var curNum,\n      nextNum = 0,\n      pointNumber;\n\n  while (done < num) {\n    done++;\n    partOffset += 4;\n    curNum = nextNum;\n\n    if (done === num) {\n      nextNum = tot;\n    } else {\n      nextNum = data.readInt32LE(partOffset);\n    }\n\n    pointNumber = nextNum - curNum;\n\n    if (!pointNumber) {\n      continue;\n    }\n\n    out.push(this.parsePointArray(data, offset, pointNumber));\n    offset += pointNumber << 4;\n  }\n\n  return out;\n};\n\nParseShp.prototype.parseZArrayGroup = function (data, zOffset, num, coordinates) {\n  var i = 0;\n\n  while (i < num) {\n    coordinates[i] = this.parseZPointArray(data, zOffset, coordinates[i].length, coordinates[i]);\n    zOffset += coordinates[i].length << 3;\n    i++;\n  }\n\n  return coordinates;\n};\n\nParseShp.prototype.parseMultiPoint = function (data) {\n  var out = {};\n  var mins = this.parseCoord(data, 0);\n  var maxs = this.parseCoord(data, 16);\n  out.bbox = [mins[0], mins[1], maxs[0], maxs[1]];\n  var num = data.readInt32LE(32, true);\n  var offset = 36;\n\n  if (num === 1) {\n    out.type = 'Point';\n    out.coordinates = this.parseCoord(data, offset);\n  } else {\n    out.type = 'MultiPoint';\n    out.coordinates = this.parsePointArray(data, offset, num);\n  }\n\n  return out;\n};\n\nParseShp.prototype.parseZMultiPoint = function (data) {\n  var geoJson = this.parseMultiPoint(data);\n  var num;\n\n  if (geoJson.type === 'Point') {\n    geoJson.coordinates.push(data.readDoubleLE(72));\n    return geoJson;\n  } else {\n    num = geoJson.coordinates.length;\n  }\n\n  var zOffset = 52 + (num << 4);\n  geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);\n  return geoJson;\n};\n\nParseShp.prototype.parsePolyline = function (data) {\n  var out = {};\n  var mins = this.parseCoord(data, 0);\n  var maxs = this.parseCoord(data, 16);\n  out.bbox = [mins[0], mins[1], maxs[0], maxs[1]];\n  var numParts = data.readInt32LE(32);\n  var num = data.readInt32LE(36);\n  var offset, partOffset;\n\n  if (numParts === 1) {\n    out.type = 'LineString';\n    offset = 44;\n    out.coordinates = this.parsePointArray(data, offset, num);\n  } else {\n    out.type = 'MultiLineString';\n    offset = 40 + (numParts << 2);\n    partOffset = 40;\n    out.coordinates = this.parseArrayGroup(data, offset, partOffset, numParts, num);\n  }\n\n  return out;\n};\n\nParseShp.prototype.parseZPolyline = function (data) {\n  var geoJson = this.parsePolyline(data);\n  var num = geoJson.coordinates.length;\n  var zOffset;\n\n  if (geoJson.type === 'LineString') {\n    zOffset = 60 + (num << 4);\n    geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);\n    return geoJson;\n  } else {\n    var totalPoints = geoJson.coordinates.reduce(function (a, v) {\n      return a + v.length;\n    }, 0);\n    zOffset = 56 + (totalPoints << 4) + (num << 2);\n    geoJson.coordinates = this.parseZArrayGroup(data, zOffset, num, geoJson.coordinates);\n    return geoJson;\n  }\n};\n\nParseShp.prototype.polyFuncs = function (out) {\n  if (out.type === 'LineString') {\n    out.type = 'Polygon';\n    out.coordinates = [out.coordinates];\n    return out;\n  } else {\n    out.coordinates = out.coordinates.reduce(polyReduce, []);\n\n    if (out.coordinates.length === 1) {\n      out.type = 'Polygon';\n      out.coordinates = out.coordinates[0];\n      return out;\n    } else {\n      out.type = 'MultiPolygon';\n      return out;\n    }\n  }\n};\n\nParseShp.prototype.parsePolygon = function (data) {\n  return this.polyFuncs(this.parsePolyline(data));\n};\n\nParseShp.prototype.parseZPolygon = function (data) {\n  return this.polyFuncs(this.parseZPolyline(data));\n};\n\nvar shpFuncObj = {\n  1: 'parsePoint',\n  3: 'parsePolyline',\n  5: 'parsePolygon',\n  8: 'parseMultiPoint',\n  11: 'parseZPoint',\n  13: 'parseZPolyline',\n  15: 'parseZPolygon',\n  18: 'parseZMultiPoint'\n};\n\nfunction makeParseCoord(trans) {\n  if (trans) {\n    return function (data, offset) {\n      return trans.inverse([data.readDoubleLE(offset), data.readDoubleLE(offset + 8)]);\n    };\n  } else {\n    return function (data, offset) {\n      return [data.readDoubleLE(offset), data.readDoubleLE(offset + 8)];\n    };\n  }\n}\n\nfunction ParseShp(buffer, trans) {\n  if (!(this instanceof ParseShp)) {\n    return new ParseShp(buffer, trans);\n  }\n\n  this.buffer = buffer;\n  this.shpFuncs(trans);\n  this.rows = this.getRows();\n}\n\nParseShp.prototype.shpFuncs = function (tran) {\n  var num = this.getShpCode();\n\n  if (num > 20) {\n    num -= 20;\n  }\n\n  if (!(num in shpFuncObj)) {\n    throw new Error('I don\\'t know that shp type');\n  }\n\n  this.parseFunc = this[shpFuncObj[num]];\n  this.parseCoord = makeParseCoord(tran);\n};\n\nParseShp.prototype.getShpCode = function () {\n  return this.parseHeader().shpCode;\n};\n\nParseShp.prototype.parseHeader = function () {\n  var view = this.buffer.slice(0, 100);\n  return {\n    length: view.readInt32BE(6 << 2),\n    version: view.readInt32LE(7 << 2),\n    shpCode: view.readInt32LE(8 << 2),\n    bbox: [view.readDoubleLE(9 << 2), view.readDoubleLE(11 << 2), view.readDoubleLE(13 << 2), view.readDoubleLE(13 << 2)]\n  };\n};\n\nParseShp.prototype.getRows = function () {\n  var offset = 100;\n  var len = this.buffer.byteLength;\n  var out = [];\n  var current;\n\n  while (offset < len) {\n    current = this.getRow(offset);\n    offset += 8;\n    offset += current.len;\n\n    if (current.type) {\n      out.push(this.parseFunc(current.data));\n    }\n  }\n\n  return out;\n};\n\nParseShp.prototype.getRow = function (offset) {\n  var view = this.buffer.slice(offset, offset + 12);\n  var len = view.readInt32BE(4) << 1;\n  var data = this.buffer.slice(offset + 12, offset + len + 8);\n  return {\n    id: view.readInt32BE(0),\n    len: len,\n    data: data,\n    type: view.readInt32LE(8)\n  };\n};\n\nmodule.exports = function (buffer, trans) {\n  return new ParseShp(buffer, trans).rows;\n};","map":null,"metadata":{},"sourceType":"script"}
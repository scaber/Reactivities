{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v22.1.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Autowired, PostConstruct } from \"../context/context\";\nimport { Events } from \"../events\";\nimport { HeaderRowComp, HeaderRowType } from \"./headerRowComp\";\nimport { BodyDropTarget } from \"./bodyDropTarget\";\nimport { _ } from \"../utils\";\nimport { Constants } from \"../constants\";\n\nvar HeaderContainer =\n/** @class */\nfunction () {\n  function HeaderContainer(eContainer, eViewport, pinned) {\n    this.headerRowComps = [];\n    this.eContainer = eContainer;\n    this.pinned = pinned;\n    this.eViewport = eViewport;\n  }\n\n  HeaderContainer.prototype.registerGridComp = function (gridPanel) {\n    this.setupDragAndDrop(gridPanel);\n  };\n\n  HeaderContainer.prototype.forEachHeaderElement = function (callback) {\n    this.headerRowComps.forEach(function (headerRowComp) {\n      return headerRowComp.forEachHeaderElement(callback);\n    });\n  };\n\n  HeaderContainer.prototype.init = function () {\n    this.scrollWidth = this.gridOptionsWrapper.getScrollbarWidth(); // if value changes, then if not pivoting, we at least need to change the label eg from sum() to avg(),\n    // if pivoting, then the columns have changed\n\n    this.eventService.addEventListener(Events.EVENT_COLUMN_VALUE_CHANGED, this.onColumnValueChanged.bind(this));\n    this.eventService.addEventListener(Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnRowGroupChanged.bind(this));\n    this.eventService.addEventListener(Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));\n    this.eventService.addEventListener(Events.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this));\n    this.eventService.addEventListener(Events.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this));\n    this.eventService.addEventListener(Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n  }; // if row group changes, that means we may need to add aggFuncs to the column headers,\n  // if the grid goes from no aggregation (ie no grouping) to grouping\n\n\n  HeaderContainer.prototype.onColumnRowGroupChanged = function () {\n    this.onGridColumnsChanged();\n  }; // if the agg func of a column changes, then we may need to update the agg func in columns header\n\n\n  HeaderContainer.prototype.onColumnValueChanged = function () {\n    this.onGridColumnsChanged();\n  };\n\n  HeaderContainer.prototype.onColumnResized = function () {\n    this.setWidthOfPinnedContainer();\n  };\n\n  HeaderContainer.prototype.onDisplayedColumnsChanged = function () {\n    this.setWidthOfPinnedContainer();\n  };\n\n  HeaderContainer.prototype.onScrollVisibilityChanged = function () {\n    this.setWidthOfPinnedContainer();\n  };\n\n  HeaderContainer.prototype.setWidthOfPinnedContainer = function () {\n    var pinningLeft = this.pinned === Constants.PINNED_LEFT;\n    var pinningRight = this.pinned === Constants.PINNED_RIGHT;\n    var controller = this.columnController;\n    var isRtl = this.gridOptionsWrapper.isEnableRtl();\n\n    if (pinningLeft || pinningRight) {\n      // size to fit all columns\n      var width = controller[pinningLeft ? 'getPinnedLeftContainerWidth' : 'getPinnedRightContainerWidth'](); // if there is a scroll showing (and taking up space, so Windows, and not iOS)\n      // in the body, then we add extra space to keep header aligned with the body,\n      // as body width fits the cols and the scrollbar\n\n      var addPaddingForScrollbar = this.scrollVisibleService.isVerticalScrollShowing() && (isRtl && pinningLeft || !isRtl && pinningRight);\n\n      if (addPaddingForScrollbar) {\n        width += this.scrollWidth;\n      }\n\n      _.setFixedWidth(this.eContainer, width);\n    }\n  };\n\n  HeaderContainer.prototype.destroy = function () {\n    this.removeHeaderRowComps();\n  };\n\n  HeaderContainer.prototype.getRowComps = function () {\n    return this.headerRowComps;\n  }; // grid cols have changed - this also means the number of rows in the header can have\n  // changed. so we remove all the old rows and insert new ones for a complete refresh\n\n\n  HeaderContainer.prototype.onGridColumnsChanged = function () {\n    this.removeAndCreateAllRowComps();\n  };\n\n  HeaderContainer.prototype.removeAndCreateAllRowComps = function () {\n    this.removeHeaderRowComps();\n    this.createHeaderRowComps();\n  }; // we expose this for gridOptions.api.refreshHeader() to call\n\n\n  HeaderContainer.prototype.refresh = function () {\n    this.removeAndCreateAllRowComps();\n  };\n\n  HeaderContainer.prototype.setupDragAndDrop = function (gridComp) {\n    var dropContainer = this.eViewport ? this.eViewport : this.eContainer;\n    var bodyDropTarget = new BodyDropTarget(this.pinned, dropContainer);\n    this.context.wireBean(bodyDropTarget);\n    bodyDropTarget.registerGridComp(gridComp);\n  };\n\n  HeaderContainer.prototype.removeHeaderRowComps = function () {\n    this.headerRowComps.forEach(function (headerRowComp) {\n      headerRowComp.destroy();\n    });\n    this.headerRowComps.length = 0;\n\n    _.clearElement(this.eContainer);\n  };\n\n  HeaderContainer.prototype.createHeaderRowComps = function () {\n    // if we are displaying header groups, then we have many rows here.\n    // go through each row of the header, one by one.\n    var rowCount = this.columnController.getHeaderRowCount();\n\n    for (var dept = 0; dept < rowCount; dept++) {\n      var groupRow = dept !== rowCount - 1;\n      var type = groupRow ? HeaderRowType.COLUMN_GROUP : HeaderRowType.COLUMN;\n      var headerRowComp = new HeaderRowComp(dept, type, this.pinned, this.dropTarget);\n      this.context.wireBean(headerRowComp);\n      this.headerRowComps.push(headerRowComp);\n      headerRowComp.getGui().setAttribute('aria-rowindex', this.headerRowComps.length.toString());\n      this.eContainer.appendChild(headerRowComp.getGui());\n    }\n\n    var includeFloatingFilterRow = this.gridOptionsWrapper.isFloatingFilter() && !this.columnController.isPivotMode();\n\n    if (includeFloatingFilterRow) {\n      var headerRowComp = new HeaderRowComp(rowCount, HeaderRowType.FLOATING_FILTER, this.pinned, this.dropTarget);\n      this.context.wireBean(headerRowComp);\n      this.headerRowComps.push(headerRowComp);\n      headerRowComp.getGui().setAttribute('aria-rowindex', this.headerRowComps.length.toString());\n      this.eContainer.appendChild(headerRowComp.getGui());\n    }\n  };\n\n  __decorate([Autowired('gridOptionsWrapper')], HeaderContainer.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([Autowired('context')], HeaderContainer.prototype, \"context\", void 0);\n\n  __decorate([Autowired('$scope')], HeaderContainer.prototype, \"$scope\", void 0);\n\n  __decorate([Autowired('dragAndDropService')], HeaderContainer.prototype, \"dragAndDropService\", void 0);\n\n  __decorate([Autowired('columnController')], HeaderContainer.prototype, \"columnController\", void 0);\n\n  __decorate([Autowired('eventService')], HeaderContainer.prototype, \"eventService\", void 0);\n\n  __decorate([Autowired('scrollVisibleService')], HeaderContainer.prototype, \"scrollVisibleService\", void 0);\n\n  __decorate([PostConstruct], HeaderContainer.prototype, \"init\", null);\n\n  return HeaderContainer;\n}();\n\nexport { HeaderContainer };","map":null,"metadata":{},"sourceType":"module"}
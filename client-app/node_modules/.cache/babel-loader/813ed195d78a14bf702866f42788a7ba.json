{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v22.1.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n// when doing transactions, or change detection, and grouping is present\n// in the data, there is no need for the ClientSideRowModel to update each\n// group after an update, ony parts that were impacted by the change.\n// this class keeps track of all groups that were impacted by a transaction.\n// the the different CSRM operations (filter, sort etc) use the forEach method\n// to visit each group that was changed.\nvar ChangedPath =\n/** @class */\nfunction () {\n  function ChangedPath(keepingColumns, rootNode) {\n    // whether changed path is active of not. it is active when a) doing\n    // a transaction update or b) doing change detection. if we are doing\n    // a CSRM refresh for other reasons (after sort or filter, or user calling\n    // setRowData() without delta mode) then we are not active. we are also\n    // marked as not active if secondary columns change in pivot (as this impacts\n    // aggregations)\n    this.active = true; // for each node in the change path, we also store which columns need\n    // to be re-aggregated.\n\n    this.nodeIdsToColumns = {}; // for quick lookup, all items in the change path are mapped by nodeId\n\n    this.mapToItems = {};\n    this.keepingColumns = keepingColumns;\n    this.pathRoot = {\n      rowNode: rootNode,\n      children: null\n    };\n    this.mapToItems[rootNode.id] = this.pathRoot;\n  } // can be set inactive by:\n  // a) ClientSideRowModel, if no transactions or\n  // b) PivotService, if secondary columns changed\n\n\n  ChangedPath.prototype.setInactive = function () {\n    this.active = false;\n  };\n\n  ChangedPath.prototype.isActive = function () {\n    return this.active;\n  };\n\n  ChangedPath.prototype.depthFirstSearchChangedPath = function (pathItem, callback) {\n    if (pathItem.children) {\n      for (var i = 0; i < pathItem.children.length; i++) {\n        this.depthFirstSearchChangedPath(pathItem.children[i], callback);\n      }\n    }\n\n    callback(pathItem.rowNode);\n  };\n\n  ChangedPath.prototype.depthFirstSearchEverything = function (rowNode, callback, traverseEverything) {\n    if (rowNode.childrenAfterGroup) {\n      for (var i = 0; i < rowNode.childrenAfterGroup.length; i++) {\n        var childNode = rowNode.childrenAfterGroup[i];\n\n        if (childNode.childrenAfterGroup) {\n          this.depthFirstSearchEverything(rowNode.childrenAfterGroup[i], callback, traverseEverything);\n        } else if (traverseEverything) {\n          callback(childNode);\n        }\n      }\n    }\n\n    callback(rowNode);\n  }; // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback\n  // will be called for child nodes in addition to parent nodes.\n\n\n  ChangedPath.prototype.forEachChangedNodeDepthFirst = function (callback, traverseLeafNodes) {\n    if (traverseLeafNodes === void 0) {\n      traverseLeafNodes = false;\n    }\n\n    if (this.active) {\n      // if we are active, then use the change path to callback\n      // only for updated groups\n      this.depthFirstSearchChangedPath(this.pathRoot, callback);\n    } else {\n      // we are not active, so callback for everything, walk the entire path\n      this.depthFirstSearchEverything(this.pathRoot.rowNode, callback, traverseLeafNodes);\n    }\n  };\n\n  ChangedPath.prototype.executeFromRootNode = function (callback) {\n    callback(this.pathRoot.rowNode);\n  };\n\n  ChangedPath.prototype.createPathItems = function (rowNode) {\n    var pointer = rowNode;\n    var newEntryCount = 0;\n\n    while (!this.mapToItems[pointer.id]) {\n      var newEntry = {\n        rowNode: pointer,\n        children: null\n      };\n      this.mapToItems[pointer.id] = newEntry;\n      newEntryCount++;\n      pointer = pointer.parent;\n    }\n\n    return newEntryCount;\n  };\n\n  ChangedPath.prototype.populateColumnsMap = function (rowNode, columns) {\n    var _this = this;\n\n    if (!this.keepingColumns || !columns) {\n      return;\n    }\n\n    var pointer = rowNode;\n\n    while (pointer) {\n      // if columns, add the columns in all the way to parent, merging\n      // in any other columns that might be there already\n      if (!this.nodeIdsToColumns[pointer.id]) {\n        this.nodeIdsToColumns[pointer.id] = {};\n      }\n\n      columns.forEach(function (col) {\n        return _this.nodeIdsToColumns[pointer.id][col.getId()] = true;\n      });\n      pointer = pointer.parent;\n    }\n  };\n\n  ChangedPath.prototype.linkPathItems = function (rowNode, newEntryCount) {\n    var pointer = rowNode;\n\n    for (var i = 0; i < newEntryCount; i++) {\n      var thisItem = this.mapToItems[pointer.id];\n      var parentItem = this.mapToItems[pointer.parent.id];\n\n      if (!parentItem.children) {\n        parentItem.children = [];\n      }\n\n      parentItem.children.push(thisItem);\n      pointer = pointer.parent;\n    }\n  }; // called by\n  // 1) change detection (provides cols) and\n  // 2) groupStage if doing transaction update (doesn't provide cols)\n\n\n  ChangedPath.prototype.addParentNode = function (rowNode, columns) {\n    if (!rowNode || rowNode.isRowPinned()) {\n      return;\n    } // we cannot do  both steps below in the same loop as\n    // the second loop has a dependency on the first loop.\n    // ie the hierarchy cannot be stitched up yet because\n    // we don't have it built yet\n    // create the new PathItem objects.\n\n\n    var newEntryCount = this.createPathItems(rowNode); // link in the node items\n\n    this.linkPathItems(rowNode, newEntryCount); // update columns\n\n    this.populateColumnsMap(rowNode, columns);\n  };\n\n  ChangedPath.prototype.canSkip = function (rowNode) {\n    return this.active && !this.mapToItems[rowNode.id];\n  };\n\n  ChangedPath.prototype.getValueColumnsForNode = function (rowNode, valueColumns) {\n    if (!this.keepingColumns) {\n      return valueColumns;\n    }\n\n    var colsForThisNode = this.nodeIdsToColumns[rowNode.id];\n    var result = valueColumns.filter(function (col) {\n      return colsForThisNode[col.getId()];\n    });\n    return result;\n  };\n\n  ChangedPath.prototype.getNotValueColumnsForNode = function (rowNode, valueColumns) {\n    if (!this.keepingColumns) {\n      return null;\n    }\n\n    var colsForThisNode = this.nodeIdsToColumns[rowNode.id];\n    var result = valueColumns.filter(function (col) {\n      return !colsForThisNode[col.getId()];\n    });\n    return result;\n  };\n\n  return ChangedPath;\n}();\n\nexport { ChangedPath };","map":null,"metadata":{},"sourceType":"module"}
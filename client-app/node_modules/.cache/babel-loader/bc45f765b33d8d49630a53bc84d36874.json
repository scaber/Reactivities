{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v22.1.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { _, Promise } from \"../utils\";\nimport { Autowired, Bean, PostConstruct, PreDestroy } from \"../context/context\";\nimport { Events } from \"../events\";\nimport { ModuleNames } from \"../modules/moduleNames\";\nimport { ModuleRegistry } from \"../modules/moduleRegistry\";\n\nvar FilterManager =\n/** @class */\nfunction () {\n  function FilterManager() {\n    this.allFilters = {};\n    this.quickFilter = null;\n    this.quickFilterParts = null; // this is true when the grid is processing the filter change. this is used by the cell comps, so that they\n    // don't flash when data changes due to filter changes. there is no need to flash when filter changes as the\n    // user is in control, so doesn't make sense to show flashing changes. for example, go to main demo where\n    // this feature is turned off (hack code to always return false for isSuppressFlashingCellsBecauseFiltering(), put in)\n    // 100,000 rows and group by country. then do some filtering. all the cells flash, which is silly.\n\n    this.processingFilterChange = false;\n  }\n\n  FilterManager_1 = FilterManager;\n\n  FilterManager.prototype.registerGridCore = function (gridCore) {\n    this.gridCore = gridCore;\n  };\n\n  FilterManager.prototype.init = function () {\n    this.eventService.addEventListener(Events.EVENT_ROW_DATA_CHANGED, this.onNewRowsLoaded.bind(this));\n    this.eventService.addEventListener(Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));\n    this.quickFilter = this.parseQuickFilter(this.gridOptionsWrapper.getQuickFilterText());\n    this.setQuickFilterParts();\n    this.allowShowChangeAfterFilter = this.gridOptionsWrapper.isAllowShowChangeAfterFilter(); // check this here, in case there is a filter from the start\n\n    this.checkExternalFilter();\n  };\n\n  FilterManager.prototype.setQuickFilterParts = function () {\n    if (this.quickFilter) {\n      this.quickFilterParts = this.quickFilter.split(' ');\n    } else {\n      this.quickFilterParts = null;\n    }\n  };\n\n  FilterManager.prototype.setFilterModel = function (model) {\n    var _this = this;\n\n    var allPromises = [];\n\n    if (model) {\n      // mark the filters as we set them, so any active filters left over we stop\n      var modelKeys_1 = Object.keys(model);\n\n      _.iterateObject(this.allFilters, function (colId, filterWrapper) {\n        _.removeFromArray(modelKeys_1, colId);\n\n        var newModel = model[colId];\n\n        _this.setModelOnFilterWrapper(filterWrapper.filterPromise, newModel);\n\n        allPromises.push(filterWrapper.filterPromise);\n      }); // at this point, processedFields contains data for which we don't have a filter working yet\n\n\n      modelKeys_1.forEach(function (colId) {\n        var column = _this.columnController.getPrimaryColumn(colId);\n\n        if (!column) {\n          console.warn('Warning ag-grid setFilterModel - no column found for colId ' + colId);\n          return;\n        }\n\n        var filterWrapper = _this.getOrCreateFilterWrapper(column, 'NO_UI');\n\n        _this.setModelOnFilterWrapper(filterWrapper.filterPromise, model[colId]);\n\n        allPromises.push(filterWrapper.filterPromise);\n      });\n    } else {\n      _.iterateObject(this.allFilters, function (key, filterWrapper) {\n        _this.setModelOnFilterWrapper(filterWrapper.filterPromise, null);\n\n        allPromises.push(filterWrapper.filterPromise);\n      });\n    }\n\n    Promise.all(allPromises).then(function (whatever) {\n      _this.onFilterChanged();\n    });\n  };\n\n  FilterManager.prototype.setModelOnFilterWrapper = function (filterPromise, newModel) {\n    filterPromise.then(function (filter) {\n      if (typeof filter.setModel !== 'function') {\n        console.warn('Warning ag-grid - filter missing setModel method, which is needed for setFilterModel');\n        return;\n      }\n\n      filter.setModel(newModel);\n    });\n  };\n\n  FilterManager.prototype.getFilterModel = function () {\n    var result = {};\n\n    _.iterateObject(this.allFilters, function (key, filterWrapper) {\n      // because user can provide filters, we provide useful error checking and messages\n      var filterPromise = filterWrapper.filterPromise;\n      var filter = filterPromise.resolveNow(null, function (filter) {\n        return filter;\n      });\n\n      if (filter == null) {\n        return null;\n      }\n\n      if (typeof filter.getModel !== 'function') {\n        console.warn('Warning ag-grid - filter API missing getModel method, which is needed for getFilterModel');\n        return;\n      }\n\n      var model = filter.getModel();\n\n      if (_.exists(model)) {\n        result[key] = model;\n      }\n    });\n\n    return result;\n  }; // returns true if any advanced filter (ie not quick filter) active\n\n\n  FilterManager.prototype.isAdvancedFilterPresent = function () {\n    return this.advancedFilterPresent;\n  }; // called by:\n  // 1) onFilterChanged()\n  // 2) onNewRowsLoaded()\n\n\n  FilterManager.prototype.setAdvancedFilterPresent = function () {\n    var atLeastOneActive = false;\n\n    _.iterateObject(this.allFilters, function (key, filterWrapper) {\n      if (filterWrapper.filterPromise.resolveNow(false, function (filter) {\n        return filter.isFilterActive();\n      })) {\n        atLeastOneActive = true;\n      }\n    });\n\n    this.advancedFilterPresent = atLeastOneActive;\n  };\n\n  FilterManager.prototype.updateFilterFlagInColumns = function (source, additionalEventAttributes) {\n    _.iterateObject(this.allFilters, function (key, filterWrapper) {\n      var filterActive = filterWrapper.filterPromise.resolveNow(false, function (filter) {\n        return filter.isFilterActive();\n      });\n      filterWrapper.column.setFilterActive(filterActive, source, additionalEventAttributes);\n    });\n  }; // returns true if quickFilter or advancedFilter\n\n\n  FilterManager.prototype.isAnyFilterPresent = function () {\n    return this.isQuickFilterPresent() || this.advancedFilterPresent || this.externalFilterPresent;\n  };\n\n  FilterManager.prototype.doesFilterPass = function (node, filterToSkip) {\n    var data = node.data;\n    var colKeys = Object.keys(this.allFilters);\n\n    for (var i = 0, l = colKeys.length; i < l; i++) {\n      // critical code, don't use functional programming\n      var colId = colKeys[i];\n      var filterWrapper = this.allFilters[colId]; // if no filter, always pass\n\n      if (filterWrapper === undefined) {\n        continue;\n      }\n\n      var filter = filterWrapper.filterPromise.resolveNow(undefined, function (filter) {\n        return filter;\n      }); // if filter not yet there, continue\n\n      if (filter === undefined) {\n        continue;\n      }\n\n      if (filter === filterToSkip) {\n        continue;\n      } // don't bother with filters that are not active\n\n\n      if (!filter.isFilterActive()) {\n        continue;\n      }\n\n      if (!filter.doesFilterPass) {\n        // because users can do custom filters, give nice error message\n        console.error('Filter is missing method doesFilterPass');\n      }\n\n      var params = {\n        node: node,\n        data: data\n      };\n\n      if (!filter.doesFilterPass(params)) {\n        return false;\n      }\n    } // all filters passed\n\n\n    return true;\n  };\n\n  FilterManager.prototype.parseQuickFilter = function (newFilter) {\n    if (_.missing(newFilter) || newFilter === \"\") {\n      return null;\n    }\n\n    if (!this.gridOptionsWrapper.isRowModelDefault()) {\n      console.warn('ag-grid: quick filtering only works with the Client-side Row Model');\n      return null;\n    }\n\n    return newFilter.toUpperCase();\n  }; // returns true if it has changed (not just same value again)\n\n\n  FilterManager.prototype.setQuickFilter = function (newFilter) {\n    var parsedFilter = this.parseQuickFilter(newFilter);\n\n    if (this.quickFilter !== parsedFilter) {\n      this.quickFilter = parsedFilter;\n      this.setQuickFilterParts();\n      this.onFilterChanged();\n    }\n  };\n\n  FilterManager.prototype.checkExternalFilter = function () {\n    this.externalFilterPresent = this.gridOptionsWrapper.isExternalFilterPresent();\n  };\n\n  FilterManager.prototype.onFilterChanged = function (additionalEventAttributes) {\n    this.setAdvancedFilterPresent();\n    this.updateFilterFlagInColumns(\"filterChanged\", additionalEventAttributes);\n    this.checkExternalFilter();\n\n    _.iterateObject(this.allFilters, function (key, filterWrapper) {\n      filterWrapper.filterPromise.then(function (filter) {\n        if (filter.onAnyFilterChanged) {\n          filter.onAnyFilterChanged();\n        }\n      });\n    });\n\n    var filterChangedEvent = {\n      type: Events.EVENT_FILTER_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n\n    if (additionalEventAttributes) {\n      _.mergeDeep(filterChangedEvent, additionalEventAttributes);\n    } // because internal events are not async in ag-grid, when the dispatchEvent\n    // method comes back, we know all listeners have finished executing.\n\n\n    this.processingFilterChange = true;\n    this.eventService.dispatchEvent(filterChangedEvent);\n    this.processingFilterChange = false;\n  };\n\n  FilterManager.prototype.isSuppressFlashingCellsBecauseFiltering = function () {\n    if (this.allowShowChangeAfterFilter) {\n      // if user has elected to always flash cell changes, then return false always\n      return false;\n    } else {\n      // otherwise we suppress flashing changes when filtering\n      return this.processingFilterChange;\n    }\n  };\n\n  FilterManager.prototype.isQuickFilterPresent = function () {\n    return this.quickFilter !== null;\n  };\n\n  FilterManager.prototype.doesRowPassOtherFilters = function (filterToSkip, node) {\n    return this.doesRowPassFilter(node, filterToSkip);\n  };\n\n  FilterManager.prototype.doesRowPassQuickFilterNoCache = function (node, filterPart) {\n    var _this = this;\n\n    var columns = this.columnController.getAllColumnsForQuickFilter();\n    var filterPasses = false;\n    columns.forEach(function (column) {\n      if (filterPasses) {\n        return;\n      }\n\n      var part = _this.getQuickFilterTextForColumn(column, node);\n\n      if (_.exists(part)) {\n        if (part.indexOf(filterPart) >= 0) {\n          filterPasses = true;\n        }\n      }\n    });\n    return filterPasses;\n  };\n\n  FilterManager.prototype.doesRowPassQuickFilterCache = function (node, filterPart) {\n    if (!node.quickFilterAggregateText) {\n      this.aggregateRowForQuickFilter(node);\n    }\n\n    var filterPasses = node.quickFilterAggregateText.indexOf(filterPart) >= 0;\n    return filterPasses;\n  };\n\n  FilterManager.prototype.doesRowPassQuickFilter = function (node) {\n    var _this = this;\n\n    var filterPasses = true;\n    var usingCache = this.gridOptionsWrapper.isCacheQuickFilter();\n    this.quickFilterParts.forEach(function (filterPart) {\n      var partPasses = usingCache ? _this.doesRowPassQuickFilterCache(node, filterPart) : _this.doesRowPassQuickFilterNoCache(node, filterPart); // each part must pass, if any fails, then the whole filter fails\n\n      if (!partPasses) {\n        filterPasses = false;\n      }\n    });\n    return filterPasses;\n  };\n\n  FilterManager.prototype.doesRowPassFilter = function (node, filterToSkip) {\n    // the row must pass ALL of the filters, so if any of them fail,\n    // we return true. that means if a row passes the quick filter,\n    // but fails the column filter, it fails overall\n    // first up, check quick filter\n    if (this.isQuickFilterPresent()) {\n      if (!this.doesRowPassQuickFilter(node)) {\n        return false;\n      }\n    } // secondly, give the client a chance to reject this row\n\n\n    if (this.externalFilterPresent) {\n      if (!this.gridOptionsWrapper.doesExternalFilterPass(node)) {\n        return false;\n      }\n    } // lastly, check our internal advanced filter\n\n\n    if (this.advancedFilterPresent) {\n      if (!this.doesFilterPass(node, filterToSkip)) {\n        return false;\n      }\n    } // got this far, all filters pass\n\n\n    return true;\n  };\n\n  FilterManager.prototype.getQuickFilterTextForColumn = function (column, rowNode) {\n    var value = this.valueService.getValue(column, rowNode, true);\n    var valueAfterCallback;\n    var colDef = column.getColDef();\n\n    if (column.getColDef().getQuickFilterText) {\n      var params = {\n        value: value,\n        node: rowNode,\n        data: rowNode.data,\n        column: column,\n        colDef: colDef,\n        context: this.gridOptionsWrapper.getContext()\n      };\n      valueAfterCallback = column.getColDef().getQuickFilterText(params);\n    } else {\n      valueAfterCallback = value;\n    }\n\n    if (_.exists(valueAfterCallback)) {\n      return valueAfterCallback.toString().toUpperCase();\n    } else {\n      return null;\n    }\n  };\n\n  FilterManager.prototype.aggregateRowForQuickFilter = function (node) {\n    var _this = this;\n\n    var stringParts = [];\n    var columns = this.columnController.getAllColumnsForQuickFilter();\n    columns.forEach(function (column) {\n      var part = _this.getQuickFilterTextForColumn(column, node);\n\n      if (_.exists(part)) {\n        stringParts.push(part);\n      }\n    });\n    node.quickFilterAggregateText = stringParts.join(FilterManager_1.QUICK_FILTER_SEPARATOR);\n  };\n\n  FilterManager.prototype.onNewRowsLoaded = function (source) {\n    _.iterateObject(this.allFilters, function (key, filterWrapper) {\n      filterWrapper.filterPromise.then(function (filter) {\n        if (filter.onNewRowsLoaded) {\n          filter.onNewRowsLoaded();\n        }\n      });\n    });\n\n    this.updateFilterFlagInColumns(source);\n    this.setAdvancedFilterPresent();\n  };\n\n  FilterManager.prototype.createValueGetter = function (column) {\n    var _this = this;\n\n    return function (node) {\n      return _this.valueService.getValue(column, node, true);\n    };\n  };\n\n  FilterManager.prototype.getFilterComponent = function (column, source) {\n    var filterWrapper = this.getOrCreateFilterWrapper(column, source);\n    return filterWrapper.filterPromise;\n  };\n\n  FilterManager.prototype.isFilterActive = function (column) {\n    var filterWrapper = this.cachedFilter(column);\n\n    if (filterWrapper) {\n      return filterWrapper.filterPromise.resolveNow(false, function (filter) {\n        return filter.isFilterActive();\n      });\n    } else {\n      return false;\n    }\n  };\n\n  FilterManager.prototype.getOrCreateFilterWrapper = function (column, source) {\n    var filterWrapper = this.cachedFilter(column);\n\n    if (!filterWrapper) {\n      filterWrapper = this.createFilterWrapper(column, source);\n      this.allFilters[column.getColId()] = filterWrapper;\n    } else {\n      if (source !== 'NO_UI') {\n        this.putIntoGui(filterWrapper, source);\n      }\n    }\n\n    return filterWrapper;\n  };\n\n  FilterManager.prototype.cachedFilter = function (column) {\n    return this.allFilters[column.getColId()];\n  };\n\n  FilterManager.prototype.createFilterInstance = function (column, $scope) {\n    var _this = this;\n\n    var defaultFilter = 'agTextColumnFilter';\n\n    if (ModuleRegistry.isRegistered(ModuleNames.SetFilterModule)) {\n      defaultFilter = 'agSetColumnFilter';\n    }\n\n    var sanitisedColDef = _.cloneObject(column.getColDef());\n\n    var filterInstance;\n    var params = this.createFilterParams(column, sanitisedColDef, $scope);\n    params.filterChangedCallback = this.onFilterChanged.bind(this);\n\n    params.filterModifiedCallback = function () {\n      var event = {\n        type: Events.EVENT_FILTER_MODIFIED,\n        api: _this.gridApi,\n        columnApi: _this.columnApi,\n        column: column,\n        filterInstance: filterInstance\n      };\n\n      _this.eventService.dispatchEvent(event);\n    }; // we modify params in a callback as we need the filter instance, and this isn't available\n    // when creating the params above\n\n\n    var modifyParamsCallback = function (params, filter) {\n      return _.assign(params, {\n        doesRowPassOtherFilter: _this.doesRowPassOtherFilters.bind(_this, filter)\n      });\n    };\n\n    var res = this.userComponentFactory.newFilterComponent(sanitisedColDef, params, defaultFilter, modifyParamsCallback);\n\n    if (res) {\n      res.then(function (r) {\n        return filterInstance = r;\n      });\n    }\n\n    return res;\n  };\n\n  FilterManager.prototype.createFilterParams = function (column, colDef, $scope) {\n    if ($scope === void 0) {\n      $scope = null;\n    }\n\n    var params = {\n      api: this.gridOptionsWrapper.getApi(),\n      column: column,\n      colDef: colDef,\n      rowModel: this.rowModel,\n      filterChangedCallback: null,\n      filterModifiedCallback: null,\n      valueGetter: this.createValueGetter(column),\n      context: this.gridOptionsWrapper.getContext(),\n      doesRowPassOtherFilter: null\n    }; // hack in scope if using AngularJS\n\n    if ($scope) {\n      params.$scope = $scope;\n    }\n\n    return params;\n  };\n\n  FilterManager.prototype.createFilterWrapper = function (column, source) {\n    var filterWrapper = {\n      column: column,\n      filterPromise: null,\n      scope: null,\n      compiledElement: null,\n      guiPromise: Promise.external()\n    };\n    filterWrapper.scope = this.gridOptionsWrapper.isAngularCompileFilters() ? this.$scope.$new() : null;\n    filterWrapper.filterPromise = this.createFilterInstance(column, filterWrapper.scope);\n\n    if (filterWrapper.filterPromise) {\n      this.putIntoGui(filterWrapper, source);\n    }\n\n    return filterWrapper;\n  };\n\n  FilterManager.prototype.putIntoGui = function (filterWrapper, source) {\n    var _this = this;\n\n    var eFilterGui = document.createElement('div');\n    eFilterGui.className = 'ag-filter';\n    filterWrapper.filterPromise.then(function (filter) {\n      var guiFromFilter = filter.getGui();\n\n      if (_.missing(guiFromFilter)) {\n        console.warn(\"getGui method from filter returned \" + guiFromFilter + \", it should be a DOM element or an HTML template string.\");\n      } // for backwards compatibility with Angular 1 - we\n      // used to allow providing back HTML from getGui().\n      // once we move away from supporting Angular 1\n      // directly, we can change this.\n\n\n      if (typeof guiFromFilter === 'string') {\n        guiFromFilter = _.loadTemplate(guiFromFilter);\n      }\n\n      eFilterGui.appendChild(guiFromFilter);\n\n      if (filterWrapper.scope) {\n        var compiledElement = _this.$compile(eFilterGui)(filterWrapper.scope);\n\n        filterWrapper.compiledElement = compiledElement;\n        window.setTimeout(function () {\n          return filterWrapper.scope.$apply();\n        }, 0);\n      }\n\n      filterWrapper.guiPromise.resolve(eFilterGui);\n\n      _this.eventService.dispatchEvent({\n        type: Events.EVENT_FILTER_OPENED,\n        column: filterWrapper.column,\n        source: source,\n        eGui: eFilterGui,\n        api: _this.gridApi,\n        columnApi: _this.columnApi\n      });\n    });\n  };\n\n  FilterManager.prototype.onNewColumnsLoaded = function () {\n    var _this = this;\n\n    var atLeastOneFilterGone = false;\n\n    _.iterateObject(this.allFilters, function (key, filterWrapper) {\n      var oldColumn = !_this.columnController.getPrimaryColumn(filterWrapper.column);\n\n      if (oldColumn) {\n        atLeastOneFilterGone = true;\n\n        _this.disposeFilterWrapper(filterWrapper, \"filterDestroyed\");\n      }\n    });\n\n    if (atLeastOneFilterGone) {\n      this.onFilterChanged();\n    }\n  }; // destroys the filter, so it not longer takes part\n\n\n  FilterManager.prototype.destroyFilter = function (column, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var filterWrapper = this.allFilters[column.getColId()];\n\n    if (filterWrapper) {\n      this.disposeFilterWrapper(filterWrapper, source);\n      this.onFilterChanged();\n    }\n  };\n\n  FilterManager.prototype.disposeFilterWrapper = function (filterWrapper, source) {\n    var _this = this;\n\n    filterWrapper.filterPromise.then(function (filter) {\n      filter.setModel(null);\n\n      if (filter.destroy) {\n        filter.destroy();\n      }\n\n      filterWrapper.column.setFilterActive(false, source);\n\n      if (filterWrapper.scope) {\n        if (filterWrapper.compiledElement) {\n          filterWrapper.compiledElement.remove();\n        }\n\n        filterWrapper.scope.$destroy();\n      }\n\n      delete _this.allFilters[filterWrapper.column.getColId()];\n    });\n  };\n\n  FilterManager.prototype.destroy = function () {\n    var _this = this;\n\n    _.iterateObject(this.allFilters, function (key, filterWrapper) {\n      _this.disposeFilterWrapper(filterWrapper, \"filterDestroyed\");\n    });\n  };\n\n  var FilterManager_1;\n  FilterManager.QUICK_FILTER_SEPARATOR = '\\n';\n\n  __decorate([Autowired('$compile')], FilterManager.prototype, \"$compile\", void 0);\n\n  __decorate([Autowired('$scope')], FilterManager.prototype, \"$scope\", void 0);\n\n  __decorate([Autowired('gridOptionsWrapper')], FilterManager.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([Autowired('popupService')], FilterManager.prototype, \"popupService\", void 0);\n\n  __decorate([Autowired('valueService')], FilterManager.prototype, \"valueService\", void 0);\n\n  __decorate([Autowired('columnController')], FilterManager.prototype, \"columnController\", void 0);\n\n  __decorate([Autowired('rowModel')], FilterManager.prototype, \"rowModel\", void 0);\n\n  __decorate([Autowired('eventService')], FilterManager.prototype, \"eventService\", void 0);\n\n  __decorate([Autowired('context')], FilterManager.prototype, \"context\", void 0);\n\n  __decorate([Autowired('columnApi')], FilterManager.prototype, \"columnApi\", void 0);\n\n  __decorate([Autowired('gridApi')], FilterManager.prototype, \"gridApi\", void 0);\n\n  __decorate([Autowired('userComponentFactory')], FilterManager.prototype, \"userComponentFactory\", void 0);\n\n  __decorate([PostConstruct], FilterManager.prototype, \"init\", null);\n\n  __decorate([PreDestroy], FilterManager.prototype, \"destroy\", null);\n\n  FilterManager = FilterManager_1 = __decorate([Bean('filterManager')], FilterManager);\n  return FilterManager;\n}();\n\nexport { FilterManager };","map":null,"metadata":{},"sourceType":"module"}
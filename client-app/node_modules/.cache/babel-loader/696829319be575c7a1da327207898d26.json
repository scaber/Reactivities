{"ast":null,"code":"'use strict';\n\nvar proj4 = require('proj4');\n\nif (proj4.default) {\n  proj4 = proj4.default;\n}\n\nvar unzip = require('./unzip');\n\nvar binaryAjax = require('./binaryajax');\n\nvar parseShp = require('./parseShp');\n\nvar parseDbf = require('parsedbf');\n\nvar Promise = require('lie');\n\nvar Cache = require('lru-cache');\n\nvar cache = new Cache({\n  max: 20\n});\n\nfunction toBuffer(b) {\n  if (!b) {\n    throw new Error('forgot to pass buffer');\n  }\n\n  if (Buffer.isBuffer(b)) {\n    return b;\n  }\n\n  if (b instanceof global.ArrayBuffer) {\n    return new Buffer(b);\n  }\n\n  if (b.buffer instanceof global.ArrayBuffer) {\n    if (b.BYTES_PER_ELEMENT === 1) {\n      return new Buffer(b);\n    }\n\n    return new Buffer(b.buffer);\n  }\n}\n\nfunction shp(base, whiteList) {\n  if (typeof base === 'string' && cache.has(base)) {\n    return Promise.resolve(cache.get(base));\n  }\n\n  return shp.getShapefile(base, whiteList).then(function (resp) {\n    if (typeof base === 'string') {\n      cache.set(base, resp);\n    }\n\n    return resp;\n  });\n}\n\nshp.combine = function (arr) {\n  var out = {};\n  out.type = 'FeatureCollection';\n  out.features = [];\n  var i = 0;\n  var len = arr[0].length;\n\n  while (i < len) {\n    out.features.push({\n      'type': 'Feature',\n      'geometry': arr[0][i],\n      'properties': arr[1][i]\n    });\n    i++;\n  }\n\n  return out;\n};\n\nshp.parseZip = function (buffer, whiteList) {\n  var key;\n  buffer = toBuffer(buffer);\n  var zip = unzip(buffer);\n  var names = [];\n  whiteList = whiteList || [];\n\n  for (key in zip) {\n    if (key.indexOf('__MACOSX') !== -1) {\n      continue;\n    }\n\n    if (key.slice(-3).toLowerCase() === 'shp') {\n      names.push(key.slice(0, -4));\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    } else if (key.slice(-3).toLowerCase() === 'prj') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = proj4(zip[key]);\n    } else if (key.slice(-4).toLowerCase() === 'json' || whiteList.indexOf(key.split('.').pop()) > -1) {\n      names.push(key.slice(0, -3) + key.slice(-3).toLowerCase());\n    } else if (key.slice(-3).toLowerCase() === 'dbf' || key.slice(-3).toLowerCase() === 'cpg') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    }\n  }\n\n  if (!names.length) {\n    throw new Error('no layers founds');\n  }\n\n  var geojson = names.map(function (name) {\n    var parsed, dbf;\n    var lastDotIdx = name.lastIndexOf('.');\n\n    if (lastDotIdx > -1 && name.slice(lastDotIdx).indexOf('json') > -1) {\n      parsed = JSON.parse(zip[name]);\n      parsed.fileName = name.slice(0, lastDotIdx);\n    } else if (whiteList.indexOf(name.slice(lastDotIdx + 1)) > -1) {\n      parsed = zip[name];\n      parsed.fileName = name;\n    } else {\n      if (zip[name + '.dbf']) {\n        dbf = parseDbf(zip[name + '.dbf'], zip[name + '.cpg']);\n      }\n\n      parsed = shp.combine([parseShp(zip[name + '.shp'], zip[name + '.prj']), dbf]);\n      parsed.fileName = name;\n    }\n\n    return parsed;\n  });\n\n  if (geojson.length === 1) {\n    return geojson[0];\n  } else {\n    return geojson;\n  }\n};\n\nfunction getZip(base, whiteList) {\n  return binaryAjax(base).then(function (a) {\n    return shp.parseZip(a, whiteList);\n  });\n}\n\nshp.getShapefile = function (base, whiteList) {\n  if (typeof base === 'string') {\n    if (base.slice(-4).toLowerCase() === '.zip') {\n      return getZip(base, whiteList);\n    } else {\n      return Promise.all([Promise.all([binaryAjax(base + '.shp'), binaryAjax(base + '.prj')]).then(function (args) {\n        return parseShp(args[0], args[1] ? proj4(args[1]) : false);\n      }), Promise.all([binaryAjax(base + '.dbf'), binaryAjax(base + '.cpg')]).then(function (args) {\n        return parseDbf(args[0], args[1]);\n      })]).then(shp.combine);\n    }\n  } else {\n    return new Promise(function (resolve) {\n      resolve(shp.parseZip(base));\n    });\n  }\n};\n\nshp.parseShp = function (shp, prj) {\n  shp = toBuffer(shp);\n\n  if (Buffer.isBuffer(prj)) {\n    prj = prj.toString();\n  }\n\n  if (typeof prj === 'string') {\n    prj = proj4(prj);\n    return parseShp(shp, prj);\n  } else {\n    return parseShp(shp);\n  }\n};\n\nshp.parseDbf = function (dbf, cpg) {\n  dbf = toBuffer(dbf);\n  return parseDbf(dbf, cpg);\n};\n\nmodule.exports = shp;","map":null,"metadata":{},"sourceType":"script"}
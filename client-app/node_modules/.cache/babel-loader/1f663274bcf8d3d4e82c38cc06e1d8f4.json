{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _Vector = _interopRequireDefault(require(\"ol/layer/Vector\"));\n\nvar _Vector2 = _interopRequireDefault(require(\"ol/source/Vector\"));\n\nvar _Collection = _interopRequireDefault(require(\"ol/Collection\"));\n\nvar _MultiPolygon = _interopRequireDefault(require(\"ol/geom/MultiPolygon\"));\n\nvar _MultiLineString = _interopRequireDefault(require(\"ol/geom/MultiLineString\"));\n\nvar _Style = _interopRequireDefault(require(\"ol/style/Style\"));\n\nvar _Stroke = _interopRequireDefault(require(\"ol/style/Stroke\"));\n\nvar _Fill = _interopRequireDefault(require(\"ol/style/Fill\"));\n\nvar _Circle = _interopRequireDefault(require(\"ol/style/Circle\"));\n\nvar _Draw = _interopRequireDefault(require(\"ol/interaction/Draw\"));\n\nvar _Observable = require(\"ol/Observable\");\n\nvar _Overlay = _interopRequireDefault(require(\"ol/Overlay\"));\n\nvar _ToggleButton = _interopRequireDefault(require(\"../ToggleButton/ToggleButton\"));\n\nvar _MeasureUtil = _interopRequireDefault(require(\"@terrestris/ol-util/dist/MeasureUtil/MeasureUtil\"));\n\nvar _MapUtil = _interopRequireDefault(require(\"@terrestris/ol-util/dist/MapUtil/MapUtil\"));\n\nvar _constants = require(\"../../constants\");\n\nrequire(\"./MeasureButton.less\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar _isEmpty = require('lodash/isEmpty');\n/**\n * The MeasureButton.\n *\n * @class The MeasureButton\n * @extends React.Component\n */\n\n\nvar MeasureButton =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(MeasureButton, _React$Component);\n  /**\n   * The className added to this component.\n   *\n   * @private\n   */\n\n  /**\n   * Currently drawn feature.\n   *\n   * @private\n   */\n\n  /**\n   * Overlay to show the measurement.\n   *\n   * @private\n   */\n\n  /**\n   * Overlay to show the help messages.\n   *\n   * @private\n   */\n\n  /**\n   * The help tooltip element.\n   *\n   * @private\n   */\n\n  /**\n   * The measure tooltip element.\n   *\n   * @private\n   */\n\n  /**\n   * An array of created overlays we use for the tooltips. Used to eventually\n   * clean up everything we added.\n   *\n   * @private\n   */\n\n  /**\n   * An array of created divs we use for the tooltips. Used to eventually\n   * clean up everything we added.\n   *\n   * @private\n   */\n\n  /**\n   * An object holding keyed `OlEventsKey` instances returned by the `on`\n   * method of `OlObservable`. These keys are used to unbind temporary\n   * listeners on events of the `OlInteractionDraw` or `OlMap`. The keys\n   * are the names of the events on the various objects. The `click` key is\n   * not always bound, but only for certain #measureType values.\n   *\n   * In #cleanup, we unbind all events we have bound so as to not leak\n   * memory, and to ensure we have no concurring listeners being active at a\n   * time (E.g. when multiple measure buttons are in an application).\n   *\n   * @private\n   */\n\n  /**\n   * The vector layer showing the geometries added by the draw interaction.\n   *\n   * @private\n   */\n\n  /**\n   * The draw interaction used to draw the geometries to measure.\n   *\n   * @private\n   */\n\n  /**\n   * The default properties.\n   */\n\n  /**\n   * Creates the MeasureButton.\n   *\n   * @constructs MeasureButton\n   */\n\n\n  function MeasureButton(props) {\n    var _this;\n\n    _classCallCheck(this, MeasureButton);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MeasureButton).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"className\", \"\".concat(_constants.CSS_PREFIX, \"measurebutton\"));\n\n    _defineProperty(_assertThisInitialized(_this), \"_feature\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_measureTooltip\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_helpTooltip\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_helpTooltipElement\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_measureTooltipElement\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_createdTooltipOverlays\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"_createdTooltipDivs\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"_eventKeys\", {\n      drawstart: null,\n      drawend: null,\n      pointermove: null,\n      click: null,\n      change: null\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_measureLayer\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_drawInteraction\", null);\n\n    _this.onDrawInteractionActiveChange = _this.onDrawInteractionActiveChange.bind(_assertThisInitialized(_this));\n    _this.onToggle = _this.onToggle.bind(_assertThisInitialized(_this));\n    _this.onDrawStart = _this.onDrawStart.bind(_assertThisInitialized(_this));\n    _this.onDrawEnd = _this.onDrawEnd.bind(_assertThisInitialized(_this));\n    _this.onDrawInteractionGeometryChange = _this.onDrawInteractionGeometryChange.bind(_assertThisInitialized(_this));\n    _this.onMapPointerMove = _this.onMapPointerMove.bind(_assertThisInitialized(_this));\n    _this.onMapClick = _this.onMapClick.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * `componentDidMount` method of the MeasureButton.\n   *\n   * @method\n   */\n\n\n  _createClass(MeasureButton, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.createMeasureLayer();\n      this.createDrawInteraction();\n    }\n    /**\n     * Called when the button is toggled, this method ensures that everything\n     * is cleaned up when unpressed, and that measuring can start when pressed.\n     *\n     * @method\n     */\n\n  }, {\n    key: \"onToggle\",\n    value: function onToggle(pressed) {\n      var _this$props = this.props,\n          map = _this$props.map,\n          onToggle = _this$props.onToggle;\n      this.cleanup();\n      onToggle(pressed);\n\n      if (pressed && this._drawInteraction) {\n        this._drawInteraction.setActive(pressed);\n\n        this._eventKeys.drawstart = this._drawInteraction.on('drawstart', this.onDrawStart, this);\n        this._eventKeys.drawend = this._drawInteraction.on('drawend', this.onDrawEnd, this);\n        this._eventKeys.pointermove = map.on('pointermove', this.onMapPointerMove, this);\n      }\n    }\n    /**\n     * Creates measure vector layer and add this to the map.\n     *\n     * @method\n     */\n\n  }, {\n    key: \"createMeasureLayer\",\n    value: function createMeasureLayer() {\n      var _this$props2 = this.props,\n          measureLayerName = _this$props2.measureLayerName,\n          fillColor = _this$props2.fillColor,\n          strokeColor = _this$props2.strokeColor,\n          map = _this$props2.map;\n\n      var measureLayer = _MapUtil[\"default\"].getLayerByName(map, measureLayerName);\n\n      if (!measureLayer) {\n        measureLayer = new _Vector[\"default\"]({\n          name: measureLayerName,\n          source: new _Vector2[\"default\"]({\n            features: new _Collection[\"default\"]()\n          }),\n          style: new _Style[\"default\"]({\n            fill: new _Fill[\"default\"]({\n              color: fillColor\n            }),\n            stroke: new _Stroke[\"default\"]({\n              color: strokeColor,\n              width: 2\n            }),\n            image: new _Circle[\"default\"]({\n              radius: 7,\n              fill: new _Fill[\"default\"]({\n                color: fillColor\n              })\n            })\n          })\n        });\n        map.addLayer(measureLayer);\n      }\n\n      this._measureLayer = measureLayer;\n    }\n    /**\n     * Creates a correctly configured OL draw interaction depending on\n     * the configured measureType.\n     *\n     * @return {OlInteractionDraw} The created interaction, which is not yet\n     *   added to the map.\n     *\n     * @method\n     */\n\n  }, {\n    key: \"createDrawInteraction\",\n    value: function createDrawInteraction() {\n      var _this$props3 = this.props,\n          fillColor = _this$props3.fillColor,\n          strokeColor = _this$props3.strokeColor,\n          measureType = _this$props3.measureType,\n          pressed = _this$props3.pressed,\n          map = _this$props3.map;\n      var maxPoints = measureType === 'angle' ? 2 : undefined;\n      var drawType = measureType === 'polygon' ? 'MultiPolygon' : 'MultiLineString';\n      var drawInteraction = new _Draw[\"default\"]({\n        name: 'react-geo_drawaction',\n        source: this._measureLayer.getSource(),\n        type: drawType,\n        maxPoints: maxPoints,\n        style: new _Style[\"default\"]({\n          fill: new _Fill[\"default\"]({\n            color: fillColor\n          }),\n          stroke: new _Stroke[\"default\"]({\n            color: strokeColor,\n            lineDash: [10, 10],\n            width: 2\n          }),\n          image: new _Circle[\"default\"]({\n            radius: 5,\n            stroke: new _Stroke[\"default\"]({\n              color: strokeColor\n            }),\n            fill: new _Fill[\"default\"]({\n              color: fillColor\n            })\n          })\n        }),\n        freehandCondition: function freehandCondition() {\n          return false;\n        }\n      });\n      map.addInteraction(drawInteraction);\n      drawInteraction.on('change:active', this.onDrawInteractionActiveChange, this);\n      this._drawInteraction = drawInteraction;\n\n      if (pressed) {\n        this.onDrawInteractionActiveChange();\n      }\n\n      drawInteraction.setActive(pressed);\n    }\n    /**\n     * Adjusts visibility of measurement related tooltips depending on active\n     * status of draw interaction.\n     */\n\n  }, {\n    key: \"onDrawInteractionActiveChange\",\n    value: function onDrawInteractionActiveChange() {\n      var showHelpTooltip = this.props.showHelpTooltip;\n\n      if (this._drawInteraction.getActive()) {\n        if (showHelpTooltip) {\n          this.createHelpTooltip();\n        }\n\n        this.createMeasureTooltip();\n      } else {\n        if (showHelpTooltip) {\n          this.removeHelpTooltip();\n        }\n\n        this.removeMeasureTooltip();\n      }\n    }\n    /**\n     * Called if the current geometry of the draw interaction has changed.\n     *\n     * @param evt The generic change event.\n     */\n\n  }, {\n    key: \"onDrawInteractionGeometryChange\",\n    value: function onDrawInteractionGeometryChange()\n    /*evt*/\n    {\n      this.updateMeasureTooltip();\n    }\n    /**\n     * Called on map click.\n     *\n     * @param evt The pointer event.\n     */\n\n  }, {\n    key: \"onMapClick\",\n    value: function onMapClick(evt) {\n      var _this$props4 = this.props,\n          measureType = _this$props4.measureType,\n          showMeasureInfoOnClickedPoints = _this$props4.showMeasureInfoOnClickedPoints;\n\n      if (showMeasureInfoOnClickedPoints && measureType === 'line') {\n        this.addMeasureStopTooltip(evt.coordinate);\n      }\n    }\n    /**\n     * Sets up listeners whenever the drawing of a measurement sketch is\n     * started.\n     *\n     * @param evt The event which contains the\n     *   feature we are drawing.\n     *\n     * @method\n     */\n\n  }, {\n    key: \"onDrawStart\",\n    value: function onDrawStart(evt) {\n      var _this$props5 = this.props,\n          showHelpTooltip = _this$props5.showHelpTooltip,\n          multipleDrawing = _this$props5.multipleDrawing,\n          map = _this$props5.map;\n\n      var source = this._measureLayer.getSource();\n\n      this._feature = evt.feature;\n      this._eventKeys.change = this._feature.getGeometry().on('change', this.onDrawInteractionGeometryChange);\n      this._eventKeys.click = map.on('click', this.onMapClick, this);\n\n      if (!multipleDrawing && source.getFeatures().length > 0) {\n        this.cleanupTooltips();\n        this.createMeasureTooltip();\n\n        if (showHelpTooltip) {\n          this.createHelpTooltip();\n        }\n\n        source.clear();\n      }\n    }\n    /**\n     * Called whenever measuring stops, this method draws static tooltips with\n     * the result onto the map canvas and unregisters various listeners.\n     *\n     * @method\n     */\n\n  }, {\n    key: \"onDrawEnd\",\n    value: function onDrawEnd(evt) {\n      var _this$props6 = this.props,\n          measureType = _this$props6.measureType,\n          multipleDrawing = _this$props6.multipleDrawing,\n          showMeasureInfoOnClickedPoints = _this$props6.showMeasureInfoOnClickedPoints,\n          measureTooltipCssClasses = _this$props6.measureTooltipCssClasses;\n\n      if (this._eventKeys.click) {\n        (0, _Observable.unByKey)(this._eventKeys.click);\n      }\n\n      if (this._eventKeys.change) {\n        (0, _Observable.unByKey)(this._eventKeys.change);\n      }\n\n      if (multipleDrawing) {\n        this.addMeasureStopTooltip(evt.feature.getGeometry().getLastCoordinate());\n      } // Fix doubled label for lastPoint of line\n\n\n      if ((multipleDrawing || showMeasureInfoOnClickedPoints) && measureType === 'line') {\n        this.removeMeasureTooltip();\n      } else {\n        this._measureTooltipElement.className = \"\".concat(measureTooltipCssClasses.tooltip, \" \").concat(measureTooltipCssClasses.tooltipStatic);\n\n        this._measureTooltip.setOffset([0, -7]);\n      }\n\n      this.updateMeasureTooltip(); // unset sketch\n\n      this._feature = null; // fix doubled label for last point of line\n\n      if ((multipleDrawing || showMeasureInfoOnClickedPoints) && measureType === 'line') {\n        this._measureTooltipElement = null;\n        this.createMeasureTooltip();\n      }\n    }\n    /**\n     * Adds a tooltip on click where a measuring stop occured.\n     *\n     * @param coordinate The coordinate for the tooltip.\n     */\n\n  }, {\n    key: \"addMeasureStopTooltip\",\n    value: function addMeasureStopTooltip(coordinate) {\n      var _this$props7 = this.props,\n          measureType = _this$props7.measureType,\n          decimalPlacesInTooltips = _this$props7.decimalPlacesInTooltips,\n          map = _this$props7.map,\n          measureTooltipCssClasses = _this$props7.measureTooltipCssClasses;\n\n      if (!_isEmpty(this._feature)) {\n        var geom = this._feature.getGeometry();\n\n        if (geom instanceof _MultiPolygon[\"default\"]) {\n          geom = geom.getPolygons()[0];\n        }\n\n        if (geom instanceof _MultiLineString[\"default\"]) {\n          geom = geom.getLineStrings()[0];\n        }\n\n        var value = measureType === 'line' ? _MeasureUtil[\"default\"].formatLength(geom, map, decimalPlacesInTooltips) : _MeasureUtil[\"default\"].formatArea(geom, map, decimalPlacesInTooltips);\n\n        if (parseInt(value, 10) > 0) {\n          var div = document.createElement('div');\n          div.className = \"\".concat(measureTooltipCssClasses.tooltip, \" \").concat(measureTooltipCssClasses.tooltipStatic);\n          div.innerHTML = value;\n          var tooltip = new _Overlay[\"default\"]({\n            element: div,\n            offset: [0, -15],\n            positioning: 'bottom-center'\n          });\n          map.addOverlay(tooltip);\n          tooltip.setPosition(coordinate);\n\n          this._createdTooltipDivs.push(div);\n\n          this._createdTooltipOverlays.push(tooltip);\n        }\n      }\n    }\n    /**\n     * Creates a new measure tooltip as `OlOverlay`.\n     */\n\n  }, {\n    key: \"createMeasureTooltip\",\n    value: function createMeasureTooltip() {\n      var _this$props8 = this.props,\n          map = _this$props8.map,\n          measureTooltipCssClasses = _this$props8.measureTooltipCssClasses;\n\n      if (this._measureTooltipElement) {\n        return;\n      }\n\n      this._measureTooltipElement = document.createElement('div');\n      this._measureTooltipElement.className = \"\".concat(measureTooltipCssClasses.tooltip, \" \").concat(measureTooltipCssClasses.tooltipDynamic);\n      this._measureTooltip = new _Overlay[\"default\"]({\n        element: this._measureTooltipElement,\n        offset: [0, -15],\n        positioning: 'bottom-center'\n      });\n      map.addOverlay(this._measureTooltip);\n    }\n    /**\n     * Creates a new help tooltip as `OlOverlay`.\n     */\n\n  }, {\n    key: \"createHelpTooltip\",\n    value: function createHelpTooltip() {\n      var _this$props9 = this.props,\n          map = _this$props9.map,\n          measureTooltipCssClasses = _this$props9.measureTooltipCssClasses;\n\n      if (this._helpTooltipElement) {\n        return;\n      }\n\n      this._helpTooltipElement = document.createElement('div');\n      this._helpTooltipElement.className = measureTooltipCssClasses.tooltip;\n      this._helpTooltip = new _Overlay[\"default\"]({\n        element: this._helpTooltipElement,\n        offset: [15, 0],\n        positioning: 'center-left'\n      });\n      map.addOverlay(this._helpTooltip);\n    }\n    /**\n     * Removes help tooltip from the map if measure button was untoggled.\n     */\n\n  }, {\n    key: \"removeHelpTooltip\",\n    value: function removeHelpTooltip() {\n      if (this._helpTooltip) {\n        this.props.map.removeOverlay(this._helpTooltip);\n      }\n\n      this._helpTooltipElement = null;\n      this._helpTooltip = null;\n    }\n    /**\n     * Removes measure tooltip from the map if measure button was untoggled.\n     *\n     * @method\n     */\n\n  }, {\n    key: \"removeMeasureTooltip\",\n    value: function removeMeasureTooltip() {\n      if (this._measureTooltip) {\n        this.props.map.removeOverlay(this._measureTooltip);\n      }\n\n      this._measureTooltipElement = null;\n      this._measureTooltip = null;\n    }\n    /**\n     * Cleans up tooltips when the button is unpressed.\n     *\n     * @method\n     */\n\n  }, {\n    key: \"cleanupTooltips\",\n    value: function cleanupTooltips() {\n      var map = this.props.map;\n\n      this._createdTooltipOverlays.forEach(function (tooltipOverlay) {\n        map.removeOverlay(tooltipOverlay);\n      });\n\n      this._createdTooltipOverlays = [];\n\n      this._createdTooltipDivs.forEach(function (tooltipDiv) {\n        var parent = tooltipDiv && tooltipDiv.parentNode;\n\n        if (parent) {\n          parent.removeChild(tooltipDiv);\n        }\n      });\n\n      this._createdTooltipDivs = [];\n      this.removeMeasureTooltip();\n    }\n    /**\n     * Cleans up artifacts from measuring when the button is unpressed.\n     *\n     * @method\n     */\n\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      var _this2 = this;\n\n      if (this._drawInteraction) {\n        this._drawInteraction.setActive(false);\n      }\n\n      Object.keys(this._eventKeys).forEach(function (key) {\n        if (_this2._eventKeys[key]) {\n          (0, _Observable.unByKey)(_this2._eventKeys[key]);\n        }\n      });\n      this.cleanupTooltips();\n\n      if (this._measureLayer) {\n        this._measureLayer.getSource().clear();\n      }\n    }\n    /**\n     * Called on map's pointermove event.\n     *\n     * @param evt The pointer event.\n     */\n\n  }, {\n    key: \"onMapPointerMove\",\n    value: function onMapPointerMove(evt) {\n      if (!evt.dragging) {\n        this.updateHelpTooltip(evt.coordinate);\n      }\n    }\n    /**\n     * Updates the position and the text of the help tooltip.\n     *\n     * @param coordinate The coordinate to center the tooltip to.\n     */\n\n  }, {\n    key: \"updateHelpTooltip\",\n    value: function updateHelpTooltip(coordinate) {\n      var _this$props10 = this.props,\n          measureType = _this$props10.measureType,\n          clickToDrawText = _this$props10.clickToDrawText,\n          continuePolygonMsg = _this$props10.continuePolygonMsg,\n          continueLineMsg = _this$props10.continueLineMsg,\n          continueAngleMsg = _this$props10.continueAngleMsg;\n\n      if (!this._helpTooltipElement) {\n        return;\n      }\n\n      var msg = clickToDrawText;\n\n      if (this._helpTooltipElement) {\n        if (measureType === 'polygon') {\n          msg = continuePolygonMsg;\n        } else if (measureType === 'line') {\n          msg = continueLineMsg;\n        } else if (measureType === 'angle') {\n          msg = continueAngleMsg;\n        }\n\n        this._helpTooltipElement.innerHTML = msg;\n\n        this._helpTooltip.setPosition(coordinate);\n      }\n    }\n    /**\n     * Updates the text and position of the measture tooltip.\n     */\n\n  }, {\n    key: \"updateMeasureTooltip\",\n    value: function updateMeasureTooltip() {\n      var _this$props11 = this.props,\n          measureType = _this$props11.measureType,\n          decimalPlacesInTooltips = _this$props11.decimalPlacesInTooltips,\n          map = _this$props11.map;\n\n      if (!this._measureTooltipElement) {\n        return;\n      }\n\n      if (this._feature) {\n        var output;\n\n        var geom = this._feature.getGeometry();\n\n        if (geom instanceof _MultiPolygon[\"default\"]) {\n          geom = geom.getPolygons()[0];\n        }\n\n        if (geom instanceof _MultiLineString[\"default\"]) {\n          geom = geom.getLineStrings()[0];\n        }\n\n        var measureTooltipCoord = geom.getLastCoordinate();\n\n        if (measureType === 'polygon') {\n          output = _MeasureUtil[\"default\"].formatArea(geom, map, decimalPlacesInTooltips); // attach area at interior point\n\n          measureTooltipCoord = geom.getInteriorPoint().getCoordinates();\n        } else if (measureType === 'line') {\n          output = _MeasureUtil[\"default\"].formatLength(geom, map, decimalPlacesInTooltips);\n        } else if (measureType === 'angle') {\n          output = _MeasureUtil[\"default\"].formatAngle(geom, map, decimalPlacesInTooltips);\n        }\n\n        this._measureTooltipElement.innerHTML = output;\n\n        this._measureTooltip.setPosition(measureTooltipCoord);\n      }\n    }\n    /**\n     * The render function.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props12 = this.props,\n          className = _this$props12.className,\n          map = _this$props12.map,\n          measureType = _this$props12.measureType,\n          measureLayerName = _this$props12.measureLayerName,\n          fillColor = _this$props12.fillColor,\n          strokeColor = _this$props12.strokeColor,\n          showMeasureInfoOnClickedPoints = _this$props12.showMeasureInfoOnClickedPoints,\n          showHelpTooltip = _this$props12.showHelpTooltip,\n          multipleDrawing = _this$props12.multipleDrawing,\n          clickToDrawText = _this$props12.clickToDrawText,\n          continuePolygonMsg = _this$props12.continuePolygonMsg,\n          continueLineMsg = _this$props12.continueLineMsg,\n          continueAngleMsg = _this$props12.continueAngleMsg,\n          decimalPlacesInTooltips = _this$props12.decimalPlacesInTooltips,\n          measureTooltipCssClasses = _this$props12.measureTooltipCssClasses,\n          onToggle = _this$props12.onToggle,\n          passThroughProps = _objectWithoutProperties(_this$props12, [\"className\", \"map\", \"measureType\", \"measureLayerName\", \"fillColor\", \"strokeColor\", \"showMeasureInfoOnClickedPoints\", \"showHelpTooltip\", \"multipleDrawing\", \"clickToDrawText\", \"continuePolygonMsg\", \"continueLineMsg\", \"continueAngleMsg\", \"decimalPlacesInTooltips\", \"measureTooltipCssClasses\", \"onToggle\"]);\n\n      var finalClassName = className ? \"\".concat(className, \" \").concat(this.className) : this.className;\n      return React.createElement(_ToggleButton[\"default\"], _extends({\n        onToggle: this.onToggle,\n        className: finalClassName\n      }, passThroughProps));\n    }\n  }]);\n\n  return MeasureButton;\n}(React.Component);\n\n_defineProperty(MeasureButton, \"defaultProps\", {\n  measureLayerName: 'react-geo_measure',\n  fillColor: 'rgba(255, 0, 0, 0.5)',\n  strokeColor: 'rgba(255, 0, 0, 0.8)',\n  showMeasureInfoOnClickedPoints: false,\n  showHelpTooltip: true,\n  decimalPlacesInTooltips: 2,\n  multipleDrawing: false,\n  continuePolygonMsg: 'Click to draw area',\n  continueLineMsg: 'Click to draw line',\n  continueAngleMsg: 'Click to draw angle',\n  clickToDrawText: 'Click to measure',\n  measureTooltipCssClasses: {\n    tooltip: \"\".concat(_constants.CSS_PREFIX, \"measure-tooltip\"),\n    tooltipDynamic: \"\".concat(_constants.CSS_PREFIX, \"measure-tooltip-dynamic\"),\n    tooltipStatic: \"\".concat(_constants.CSS_PREFIX, \"measure-tooltip-static\")\n  },\n  pressed: false,\n  onToggle: function onToggle() {\n    return undefined;\n  }\n});\n\nvar _default = MeasureButton;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}
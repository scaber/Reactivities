{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v22.1.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Autowired, Bean, PostConstruct, PreDestroy } from \"../context/context\";\nimport { Constants } from \"../constants\";\n/**\n * For Master Detail, it is required to keep components between expanding & collapsing parents.\n * For example a user expands row A (and shows a detail grid for this row), then when row A\n * is closed, we want to keep the detail grid, so next time row A is expanded the detail grid\n * is showed with it's context intact, eg if user sorted in the detail grid, that sort should\n * still be applied after the detail grid is shown for the second time.\n */\n\nvar DetailRowCompCache =\n/** @class */\nfunction () {\n  function DetailRowCompCache() {\n    this.cacheItems = [];\n  }\n\n  DetailRowCompCache.prototype.postConstruct = function () {\n    this.active = this.gridOptionsWrapper.isKeepDetailRows();\n    this.maxCacheSize = this.gridOptionsWrapper.getKeepDetailRowsCount();\n  };\n\n  DetailRowCompCache.prototype.addOrDestroy = function (rowNode, pinned, comp) {\n    // only accept detail rows\n    var doNotUseCache = !this.active || !rowNode.detail;\n\n    if (doNotUseCache) {\n      this.destroyFullWidthRow(comp);\n      return;\n    }\n\n    var item = this.getCacheItem(rowNode, true); // put the comp in the right location of the item.\n    // we also destroy any previous comp - this should never happen\n    // as the logic outside of this class shouldn't be adding same item to the\n    // cache twice, however we cater for it in case in future releases code\n    // outside of this class is changed and this could happen.\n\n    switch (pinned) {\n      case Constants.PINNED_LEFT:\n        this.destroyFullWidthRow(item.left);\n        item.left = comp;\n        break;\n\n      case Constants.PINNED_RIGHT:\n        this.destroyFullWidthRow(item.right);\n        item.right = comp;\n        break;\n\n      default:\n        this.destroyFullWidthRow(item.center);\n        item.center = comp;\n        break;\n    }\n\n    this.cacheItems.sort(function (a, b) {\n      return b.lastAccessedTime - a.lastAccessedTime;\n    });\n    this.purgeCache(this.maxCacheSize);\n  };\n\n  DetailRowCompCache.prototype.getCacheItem = function (rowNode, autoCreate) {\n    if (autoCreate === void 0) {\n      autoCreate = false;\n    }\n\n    var res;\n\n    for (var i = 0; i < this.cacheItems.length; i++) {\n      var item = this.cacheItems[i];\n\n      if (item.rowNode === rowNode) {\n        res = item;\n        break;\n      }\n    }\n\n    if (!res && autoCreate) {\n      res = {\n        rowNode: rowNode\n      };\n      this.cacheItems.push(res);\n    }\n\n    if (res) {\n      this.stampCacheItem(res);\n    }\n\n    return res;\n  };\n\n  DetailRowCompCache.prototype.stampCacheItem = function (item) {\n    item.lastAccessedTime = new Date().getTime();\n  };\n\n  DetailRowCompCache.prototype.destroyFullWidthRow = function (comp) {\n    if (comp && comp.destroy) {\n      comp.destroy();\n    }\n  };\n\n  DetailRowCompCache.prototype.purgeCache = function (startIndex) {\n    // delete all rows past the index of interest\n    for (var i = startIndex; i < this.cacheItems.length; i++) {\n      var item = this.cacheItems[i];\n      this.destroyFullWidthRow(item.center);\n      this.destroyFullWidthRow(item.left);\n      this.destroyFullWidthRow(item.right);\n    } // change the length of the array so it no longer contains the deleted items\n\n\n    if (this.cacheItems.length > startIndex) {\n      this.cacheItems.length = startIndex;\n    }\n  };\n\n  DetailRowCompCache.prototype.get = function (rowNode, pinned) {\n    if (!rowNode.detail) {\n      return undefined;\n    }\n\n    var item = this.getCacheItem(rowNode);\n    var res;\n\n    if (item) {\n      switch (pinned) {\n        case Constants.PINNED_LEFT:\n          if (item.left) {\n            res = item.left;\n            item.left = undefined;\n          }\n\n          break;\n\n        case Constants.PINNED_RIGHT:\n          if (item.right) {\n            res = item.right;\n            item.right = undefined;\n          }\n\n          break;\n\n        default:\n          if (item.center) {\n            res = item.center;\n            item.center = undefined;\n          }\n\n          break;\n      }\n    }\n\n    return res;\n  };\n\n  DetailRowCompCache.prototype.destroy = function () {\n    this.purgeCache(0);\n  };\n\n  __decorate([Autowired('gridOptionsWrapper')], DetailRowCompCache.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([PostConstruct], DetailRowCompCache.prototype, \"postConstruct\", null);\n\n  __decorate([PreDestroy], DetailRowCompCache.prototype, \"destroy\", null);\n\n  DetailRowCompCache = __decorate([Bean('detailRowCompCache')], DetailRowCompCache);\n  return DetailRowCompCache;\n}();\n\nexport { DetailRowCompCache };","map":null,"metadata":{},"sourceType":"module"}
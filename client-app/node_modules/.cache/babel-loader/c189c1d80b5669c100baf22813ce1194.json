{"ast":null,"code":";\n\n(function () {\n  // closure for web browsers\n  if (typeof module === 'object' && module.exports) {\n    module.exports = LRUCache;\n  } else {\n    // just set the global for non-node platforms.\n    this.LRUCache = LRUCache;\n  }\n\n  function hOP(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  }\n\n  function naiveLength() {\n    return 1;\n  }\n\n  var didTypeWarning = false;\n\n  function typeCheckKey(key) {\n    if (!didTypeWarning && typeof key !== 'string' && typeof key !== 'number') {\n      didTypeWarning = true;\n      console.error(new TypeError(\"LRU: key must be a string or number. Almost certainly a bug! \" + typeof key).stack);\n    }\n  }\n\n  function LRUCache(options) {\n    if (!(this instanceof LRUCache)) return new LRUCache(options);\n    if (typeof options === 'number') options = {\n      max: options\n    };\n    if (!options) options = {};\n    this._max = options.max; // Kind of weird to have a default max of Infinity, but oh well.\n\n    if (!this._max || !(typeof this._max === \"number\") || this._max <= 0) this._max = Infinity;\n    this._lengthCalculator = options.length || naiveLength;\n    if (typeof this._lengthCalculator !== \"function\") this._lengthCalculator = naiveLength;\n    this._allowStale = options.stale || false;\n    this._maxAge = options.maxAge || null;\n    this._dispose = options.dispose;\n    this.reset();\n  } // resize the cache when the max changes.\n\n\n  Object.defineProperty(LRUCache.prototype, \"max\", {\n    set: function (mL) {\n      if (!mL || !(typeof mL === \"number\") || mL <= 0) mL = Infinity;\n      this._max = mL;\n      if (this._length > this._max) trim(this);\n    },\n    get: function () {\n      return this._max;\n    },\n    enumerable: true\n  }); // resize the cache when the lengthCalculator changes.\n\n  Object.defineProperty(LRUCache.prototype, \"lengthCalculator\", {\n    set: function (lC) {\n      if (typeof lC !== \"function\") {\n        this._lengthCalculator = naiveLength;\n        this._length = this._itemCount;\n\n        for (var key in this._cache) {\n          this._cache[key].length = 1;\n        }\n      } else {\n        this._lengthCalculator = lC;\n        this._length = 0;\n\n        for (var key in this._cache) {\n          this._cache[key].length = this._lengthCalculator(this._cache[key].value);\n          this._length += this._cache[key].length;\n        }\n      }\n\n      if (this._length > this._max) trim(this);\n    },\n    get: function () {\n      return this._lengthCalculator;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(LRUCache.prototype, \"length\", {\n    get: function () {\n      return this._length;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(LRUCache.prototype, \"itemCount\", {\n    get: function () {\n      return this._itemCount;\n    },\n    enumerable: true\n  });\n\n  LRUCache.prototype.forEach = function (fn, thisp) {\n    thisp = thisp || this;\n    var i = 0;\n    var itemCount = this._itemCount;\n\n    for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {\n      i++;\n      var hit = this._lruList[k];\n\n      if (isStale(this, hit)) {\n        del(this, hit);\n        if (!this._allowStale) hit = undefined;\n      }\n\n      if (hit) {\n        fn.call(thisp, hit.value, hit.key, this);\n      }\n    }\n  };\n\n  LRUCache.prototype.keys = function () {\n    var keys = new Array(this._itemCount);\n    var i = 0;\n\n    for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n      var hit = this._lruList[k];\n      keys[i++] = hit.key;\n    }\n\n    return keys;\n  };\n\n  LRUCache.prototype.values = function () {\n    var values = new Array(this._itemCount);\n    var i = 0;\n\n    for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n      var hit = this._lruList[k];\n      values[i++] = hit.value;\n    }\n\n    return values;\n  };\n\n  LRUCache.prototype.reset = function () {\n    if (this._dispose && this._cache) {\n      for (var k in this._cache) {\n        this._dispose(k, this._cache[k].value);\n      }\n    }\n\n    this._cache = Object.create(null); // hash of items by key\n\n    this._lruList = Object.create(null); // list of items in order of use recency\n\n    this._mru = 0; // most recently used\n\n    this._lru = 0; // least recently used\n\n    this._length = 0; // number of items in the list\n\n    this._itemCount = 0;\n  };\n\n  LRUCache.prototype.dump = function () {\n    var arr = [];\n    var i = 0;\n\n    for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n      var hit = this._lruList[k];\n\n      if (!isStale(this, hit)) {\n        //Do not store staled hits\n        ++i;\n        arr.push({\n          k: hit.key,\n          v: hit.value,\n          e: hit.now + (hit.maxAge || 0)\n        });\n      }\n    } //arr has the most read first\n\n\n    return arr;\n  };\n\n  LRUCache.prototype.dumpLru = function () {\n    return this._lruList;\n  };\n\n  LRUCache.prototype.set = function (key, value, maxAge) {\n    maxAge = maxAge || this._maxAge;\n    typeCheckKey(key);\n    var now = maxAge ? Date.now() : 0;\n\n    var len = this._lengthCalculator(value);\n\n    if (hOP(this._cache, key)) {\n      if (len > this._max) {\n        del(this, this._cache[key]);\n        return false;\n      } // dispose of the old one before overwriting\n\n\n      if (this._dispose) this._dispose(key, this._cache[key].value);\n      this._cache[key].now = now;\n      this._cache[key].maxAge = maxAge;\n      this._cache[key].value = value;\n      this._length += len - this._cache[key].length;\n      this._cache[key].length = len;\n      this.get(key);\n      if (this._length > this._max) trim(this);\n      return true;\n    }\n\n    var hit = new Entry(key, value, this._mru++, len, now, maxAge); // oversized objects fall out of cache automatically.\n\n    if (hit.length > this._max) {\n      if (this._dispose) this._dispose(key, value);\n      return false;\n    }\n\n    this._length += hit.length;\n    this._lruList[hit.lu] = this._cache[key] = hit;\n    this._itemCount++;\n    if (this._length > this._max) trim(this);\n    return true;\n  };\n\n  LRUCache.prototype.has = function (key) {\n    typeCheckKey(key);\n    if (!hOP(this._cache, key)) return false;\n    var hit = this._cache[key];\n\n    if (isStale(this, hit)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  LRUCache.prototype.get = function (key) {\n    typeCheckKey(key);\n    return get(this, key, true);\n  };\n\n  LRUCache.prototype.peek = function (key) {\n    typeCheckKey(key);\n    return get(this, key, false);\n  };\n\n  LRUCache.prototype.pop = function () {\n    var hit = this._lruList[this._lru];\n    del(this, hit);\n    return hit || null;\n  };\n\n  LRUCache.prototype.del = function (key) {\n    typeCheckKey(key);\n    del(this, this._cache[key]);\n  };\n\n  LRUCache.prototype.load = function (arr) {\n    //reset the cache\n    this.reset();\n    var now = Date.now(); //A previous serialized cache has the most recent items first\n\n    for (var l = arr.length - 1; l >= 0; l--) {\n      var hit = arr[l];\n      typeCheckKey(hit.k);\n      var expiresAt = hit.e || 0;\n\n      if (expiresAt === 0) {\n        //the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v);\n      } else {\n        var maxAge = expiresAt - now; //dont add already expired items\n\n        if (maxAge > 0) this.set(hit.k, hit.v, maxAge);\n      }\n    }\n  };\n\n  function get(self, key, doUse) {\n    typeCheckKey(key);\n    var hit = self._cache[key];\n\n    if (hit) {\n      if (isStale(self, hit)) {\n        del(self, hit);\n        if (!self._allowStale) hit = undefined;\n      } else {\n        if (doUse) use(self, hit);\n      }\n\n      if (hit) hit = hit.value;\n    }\n\n    return hit;\n  }\n\n  function isStale(self, hit) {\n    if (!hit || !hit.maxAge && !self._maxAge) return false;\n    var stale = false;\n    var diff = Date.now() - hit.now;\n\n    if (hit.maxAge) {\n      stale = diff > hit.maxAge;\n    } else {\n      stale = self._maxAge && diff > self._maxAge;\n    }\n\n    return stale;\n  }\n\n  function use(self, hit) {\n    shiftLU(self, hit);\n    hit.lu = self._mru++;\n    self._lruList[hit.lu] = hit;\n  }\n\n  function trim(self) {\n    while (self._lru < self._mru && self._length > self._max) del(self, self._lruList[self._lru]);\n  }\n\n  function shiftLU(self, hit) {\n    delete self._lruList[hit.lu];\n\n    while (self._lru < self._mru && !self._lruList[self._lru]) self._lru++;\n  }\n\n  function del(self, hit) {\n    if (hit) {\n      if (self._dispose) self._dispose(hit.key, hit.value);\n      self._length -= hit.length;\n      self._itemCount--;\n      delete self._cache[hit.key];\n      shiftLU(self, hit);\n    }\n  } // classy, since V8 prefers predictable objects.\n\n\n  function Entry(key, value, lu, length, now, maxAge) {\n    this.key = key;\n    this.value = value;\n    this.lu = lu;\n    this.length = length;\n    this.now = now;\n    if (maxAge) this.maxAge = maxAge;\n  }\n})();","map":null,"metadata":{},"sourceType":"script"}
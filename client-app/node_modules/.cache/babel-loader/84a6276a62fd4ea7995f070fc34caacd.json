{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _sphere = require(\"ol/sphere\");\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * This class provides some static methods which might be helpful when working\n * with measurements.\n *\n * @class MeasureUtil\n */\n\n\nvar MeasureUtil =\n/*#__PURE__*/\nfunction () {\n  function MeasureUtil() {\n    _classCallCheck(this, MeasureUtil);\n  }\n\n  _createClass(MeasureUtil, null, [{\n    key: \"getLength\",\n\n    /**\n     * Get the length of a OlGeomLineString.\n     *\n     * @param {OlGeomLineString} line The drawn line.\n     * @param {OlMap} map An OlMap.\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     * @param {number} radius Sphere radius. By default, the radius of the earth\n     *                        is used (Clarke 1866 Authalic Sphere, 6371008.8).\n     *\n     * @return {number} The length of line in meters.\n     */\n    value: function getLength(line, map) {\n      var geodesic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371008.8;\n\n      if (geodesic) {\n        var opts = {\n          projection: map.getView().getProjection().getCode(),\n          radius: radius\n        };\n        return (0, _sphere.getLength)(line, opts);\n      } else {\n        return Math.round(line.getLength() * 100) / 100;\n      }\n    }\n    /**\n     * Format length output for the tooltip.\n     *\n     * @param {OlGeomLineString} line The drawn line.\n     * @param {OlMap} map An OlMap.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     *\n     * @return {string} The formatted length of the line.\n     */\n\n  }, {\n    key: \"formatLength\",\n    value: function formatLength(line, map, decimalPlacesInToolTips) {\n      var geodesic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var decimalHelper = Math.pow(10, decimalPlacesInToolTips);\n      var length = MeasureUtil.getLength(line, map, geodesic);\n      var output;\n\n      if (length > 1000) {\n        output = Math.round(length / 1000 * decimalHelper) / decimalHelper + ' km';\n      } else {\n        output = Math.round(length * decimalHelper) / decimalHelper + ' m';\n      }\n\n      return output;\n    }\n    /**\n     * Get the area of a OlGeomPolygon.\n     *\n     * @param {OlGeomPolygon} polygon The drawn polygon.\n     * @param {OlMap} map An OlMap.\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     * @param {number} radius Sphere radius. By default, the radius of the earth\n     *                        is used (Clarke 1866 Authalic Sphere, 6371008.8).\n     *\n     * @return {number} The area of the polygon in square meter.\n     */\n\n  }, {\n    key: \"getArea\",\n    value: function getArea(polygon, map) {\n      var geodesic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371008.8;\n\n      if (geodesic) {\n        var opts = {\n          projection: map.getView().getProjection().getCode(),\n          radius: radius\n        };\n        return (0, _sphere.getArea)(polygon, opts);\n      } else {\n        return polygon.getArea();\n      }\n    }\n    /**\n     * Format length output for the tooltip.\n     *\n     * @param {OlGeomPolygon} polygon The drawn polygon.\n     * @param {OlMap} map An OlMap.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips.\n     * @param {boolean} geodesic Is the measurement geodesic.\n     *\n     * @return {string} The formatted area of the polygon.\n     */\n\n  }, {\n    key: \"formatArea\",\n    value: function formatArea(polygon, map, decimalPlacesInToolTips) {\n      var geodesic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var decimalHelper = Math.pow(10, decimalPlacesInToolTips);\n      var area = MeasureUtil.getArea(polygon, map, geodesic);\n      var output;\n\n      if (area > 10000) {\n        output = Math.round(area / 1000000 * decimalHelper) / decimalHelper + ' km<sup>2</sup>';\n      } else {\n        output = Math.round(area * decimalHelper) / decimalHelper + ' m<sup>2</sup>';\n      }\n\n      return output;\n    }\n    /**\n     * Determine the angle between two coordinates. The angle will be between\n     * -180° and 180°, with 0° being in the east. The angle will increase\n     * counter-clockwise.\n     *\n     * Inspired by https://stackoverflow.com/a/31136507\n     *\n     * @param {Array<number>} start The start coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     * @param {Array<number>} end The end coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     *\n     * @return {number} the angle in degreees, ranging from -180° to 180°.\n     */\n\n  }, {\n    key: \"angle\",\n    value: function angle(start, end) {\n      var dx = start[0] - end[0];\n      var dy = start[1] - end[1]; // range (-PI, PI]\n\n      var theta = Math.atan2(dy, dx); // rads to degs, range (-180, 180]\n\n      theta *= 180 / Math.PI;\n      return theta;\n    }\n    /**\n     * Determine the angle between two coordinates. The angle will be between\n     * 0° and 360°, with 0° being in the east. The angle will increase\n     * counter-clockwise.\n     *\n     * Inspired by https://stackoverflow.com/a/31136507\n     *\n     * @param {Array<number>} start The start coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     * @param {Array<number>} end The end coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     *\n     * @return {number} the angle in degrees, ranging from 0° and 360°.\n     */\n\n  }, {\n    key: \"angle360\",\n    value: function angle360(start, end) {\n      // range (-180, 180]\n      var theta = MeasureUtil.angle(start, end);\n\n      if (theta < 0) {\n        // range [0, 360)\n        theta = 360 + theta;\n      }\n\n      return theta;\n    }\n    /**\n     * Given an angle between 0° and 360° this angle returns the exact opposite\n     * of the angle, e.g. for 90° you'll get back 270°. This effectively turns\n     * the direction of the angle from counter-clockwise to clockwise.\n     *\n     * @param {number} angle360 The input angle obtained counter-clockwise.\n     *\n     * @return {number} The clockwise angle.\n     */\n\n  }, {\n    key: \"makeClockwise\",\n    value: function makeClockwise(angle360) {\n      return 360 - angle360;\n    }\n    /**\n     * This methods adds an offset of 90° to an counter-clockwise increasing\n     * angle of a line so that the origin (0°) lies at the top (in the north).\n     *\n     * @param {number} angle360 The input angle obtained counter-clockwise, with\n     *     0° degrees being in the east.\n     *\n     * @return {number} The adjusted angle, with 0° being in the north.\n     */\n\n  }, {\n    key: \"makeZeroDegreesAtNorth\",\n    value: function makeZeroDegreesAtNorth(angle360) {\n      var corrected = angle360 + 90;\n\n      if (corrected > 360) {\n        corrected = corrected - 360;\n      }\n\n      return corrected;\n    }\n    /**\n     * Returns the angle of the passed linestring in degrees, with 'N' being the\n     * 0°-line and the angle increases in clockwise direction.\n     *\n     * @param {OlGeomLineString} line The linestring to get the\n     *   angle from. As this line is comming from our internal draw\n     *   interaction, we know that it will only consist of two points.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips.\n     *\n     * @return {string} The formatted angle of the line.\n     */\n\n  }, {\n    key: \"formatAngle\",\n    value: function formatAngle(line) {\n      var decimalPlacesInToolTips = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      var coords = line.getCoordinates();\n      var numCoords = coords.length;\n\n      if (numCoords < 2) {\n        return '';\n      }\n\n      var lastPoint = coords[numCoords - 1];\n      var prevPoint = coords[numCoords - 2];\n      var angle = MeasureUtil.angle360(prevPoint, lastPoint);\n      angle = MeasureUtil.makeZeroDegreesAtNorth(angle);\n      angle = MeasureUtil.makeClockwise(angle);\n      angle = angle.toFixed(decimalPlacesInToolTips);\n      return \"\".concat(angle, \"\\xB0\");\n    }\n  }]);\n\n  return MeasureUtil;\n}();\n\nvar _default = MeasureUtil;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"import { RowNode, Events, _ } from \"@ag-grid-community/core\";\n\nvar ClientSideNodeManager =\n/** @class */\nfunction () {\n  function ClientSideNodeManager(rootNode, gridOptionsWrapper, context, eventService, columnController, gridApi, columnApi, selectionController) {\n    this.nextId = 0; // when user is provide the id's, we also keep a map of ids to row nodes for convenience\n\n    this.allNodesMap = {};\n    this.rootNode = rootNode;\n    this.gridOptionsWrapper = gridOptionsWrapper;\n    this.context = context;\n    this.eventService = eventService;\n    this.columnController = columnController;\n    this.gridApi = gridApi;\n    this.columnApi = columnApi;\n    this.selectionController = selectionController;\n    this.rootNode.group = true;\n    this.rootNode.level = -1;\n    this.rootNode.id = ClientSideNodeManager.ROOT_NODE_ID;\n    this.rootNode.allLeafChildren = [];\n    this.rootNode.childrenAfterGroup = [];\n    this.rootNode.childrenAfterSort = [];\n    this.rootNode.childrenAfterFilter = []; // if we make this class a bean, then can annotate postConstruct\n\n    this.postConstruct();\n  } // @PostConstruct - this is not a bean, so postConstruct called by constructor\n\n\n  ClientSideNodeManager.prototype.postConstruct = function () {\n    // func below doesn't have 'this' pointer, so need to pull out these bits\n    this.getNodeChildDetails = this.gridOptionsWrapper.getNodeChildDetailsFunc();\n    this.suppressParentsInRowNodes = this.gridOptionsWrapper.isSuppressParentsInRowNodes();\n    this.doesDataFlower = this.gridOptionsWrapper.getDoesDataFlowerFunc();\n    this.isRowMasterFunc = this.gridOptionsWrapper.getIsRowMasterFunc();\n    this.doingLegacyTreeData = _.exists(this.getNodeChildDetails);\n    this.doingMasterDetail = this.gridOptionsWrapper.isMasterDetail();\n\n    if (this.getNodeChildDetails) {\n      console.warn(\"ag-Grid: the callback nodeChildDetailsFunc() is now deprecated. The new way of doing\\n                                    tree data in ag-Grid was introduced in v14 (released November 2017). In the next\\n                                    major release of ag-Grid we will be dropping support for the old version of\\n                                    tree data. If you are reading this message, please go to the docs to see how\\n                                    to implement Tree Data without using nodeChildDetailsFunc().\");\n    }\n  };\n\n  ClientSideNodeManager.prototype.getCopyOfNodesMap = function () {\n    var result = _.cloneObject(this.allNodesMap);\n\n    return result;\n  };\n\n  ClientSideNodeManager.prototype.getRowNode = function (id) {\n    return this.allNodesMap[id];\n  };\n\n  ClientSideNodeManager.prototype.setRowData = function (rowData) {\n    this.rootNode.childrenAfterFilter = null;\n    this.rootNode.childrenAfterGroup = null;\n    this.rootNode.childrenAfterSort = null;\n    this.rootNode.childrenMapped = null;\n    this.nextId = 0;\n    this.allNodesMap = {};\n\n    if (!rowData) {\n      this.rootNode.allLeafChildren = [];\n      this.rootNode.childrenAfterGroup = [];\n      return;\n    } // kick off recursion\n    // we add rootNode as the parent, however if using ag-grid-enterprise, the grouping stage\n    // sets the parent node on each row (even if we are not grouping). so setting parent node\n    // here is for benefit of ag-grid-community users\n\n\n    var result = this.recursiveFunction(rowData, this.rootNode, ClientSideNodeManager.TOP_LEVEL);\n\n    if (this.doingLegacyTreeData) {\n      this.rootNode.childrenAfterGroup = result;\n      this.setLeafChildren(this.rootNode);\n    } else {\n      this.rootNode.allLeafChildren = result;\n    }\n  };\n\n  ClientSideNodeManager.prototype.updateRowData = function (rowDataTran, rowNodeOrder) {\n    if (this.isLegacyTreeData()) {\n      return null;\n    }\n\n    var rowNodeTransaction = {\n      remove: [],\n      update: [],\n      add: []\n    };\n    this.executeAdd(rowDataTran, rowNodeTransaction);\n    this.executeRemove(rowDataTran, rowNodeTransaction);\n    this.executeUpdate(rowDataTran, rowNodeTransaction);\n\n    if (rowNodeOrder) {\n      _.sortRowNodesByOrder(this.rootNode.allLeafChildren, rowNodeOrder);\n    }\n\n    return rowNodeTransaction;\n  };\n\n  ClientSideNodeManager.prototype.executeAdd = function (rowDataTran, rowNodeTransaction) {\n    var _this = this;\n\n    var add = rowDataTran.add,\n        addIndex = rowDataTran.addIndex;\n\n    if (!add) {\n      return;\n    }\n\n    var useIndex = typeof addIndex === 'number' && addIndex >= 0;\n\n    if (useIndex) {\n      // items get inserted in reverse order for index insertion\n      add.reverse().forEach(function (item) {\n        var newRowNode = _this.addRowNode(item, addIndex);\n\n        rowNodeTransaction.add.push(newRowNode);\n      });\n    } else {\n      add.forEach(function (item) {\n        var newRowNode = _this.addRowNode(item);\n\n        rowNodeTransaction.add.push(newRowNode);\n      });\n    }\n  };\n\n  ClientSideNodeManager.prototype.executeRemove = function (rowDataTran, rowNodeTransaction) {\n    var _this = this;\n\n    var remove = rowDataTran.remove;\n\n    if (!remove) {\n      return;\n    }\n\n    var rowIdsRemoved = {};\n    var anyNodesSelected = false;\n    remove.forEach(function (item) {\n      var rowNode = _this.lookupRowNode(item);\n\n      if (!rowNode) {\n        return;\n      }\n\n      if (rowNode.isSelected()) {\n        anyNodesSelected = true;\n      } // do delete - setting 'tailingNodeInSequence = true' to ensure EVENT_SELECTION_CHANGED is not raised for\n      // each row node updated, instead it is raised once by the calling code if any selected nodes exist.\n\n\n      rowNode.setSelected(false, false, true); // so row renderer knows to fade row out (and not reposition it)\n\n      rowNode.clearRowTop(); // NOTE: were we could remove from allLeaveChildren, however _.removeFromArray() is expensive, especially\n      // if called multiple times (eg deleting lots of rows) and if allLeafChildren is a large list\n\n      rowIdsRemoved[rowNode.id] = true; // _.removeFromArray(this.rootNode.allLeafChildren, rowNode);\n\n      delete _this.allNodesMap[rowNode.id];\n      rowNodeTransaction.remove.push(rowNode);\n    });\n    this.rootNode.allLeafChildren = this.rootNode.allLeafChildren.filter(function (rowNode) {\n      return !rowIdsRemoved[rowNode.id];\n    });\n\n    if (anyNodesSelected) {\n      this.selectionController.updateGroupsFromChildrenSelections();\n      var event_1 = {\n        type: Events.EVENT_SELECTION_CHANGED,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_1);\n    }\n  };\n\n  ClientSideNodeManager.prototype.executeUpdate = function (rowDataTran, rowNodeTransaction) {\n    var _this = this;\n\n    var update = rowDataTran.update;\n\n    if (!update) {\n      return;\n    }\n\n    update.forEach(function (item) {\n      var rowNode = _this.lookupRowNode(item);\n\n      if (!rowNode) {\n        return;\n      }\n\n      rowNode.updateData(item);\n      rowNodeTransaction.update.push(rowNode);\n    });\n  };\n\n  ClientSideNodeManager.prototype.addRowNode = function (data, index) {\n    var newNode = this.createNode(data, this.rootNode, ClientSideNodeManager.TOP_LEVEL);\n\n    if (_.exists(index)) {\n      _.insertIntoArray(this.rootNode.allLeafChildren, newNode, index);\n    } else {\n      this.rootNode.allLeafChildren.push(newNode);\n    }\n\n    return newNode;\n  };\n\n  ClientSideNodeManager.prototype.lookupRowNode = function (data) {\n    var rowNodeIdFunc = this.gridOptionsWrapper.getRowNodeIdFunc();\n    var rowNode;\n\n    if (_.exists(rowNodeIdFunc)) {\n      // find rowNode using id\n      var id = rowNodeIdFunc(data);\n      rowNode = this.allNodesMap[id];\n\n      if (!rowNode) {\n        console.error(\"ag-Grid: could not find row id=\" + id + \", data item was not found for this id\");\n        return null;\n      }\n    } else {\n      // find rowNode using object references\n      rowNode = _.find(this.rootNode.allLeafChildren, function (rowNode) {\n        return rowNode.data === data;\n      });\n\n      if (!rowNode) {\n        console.error(\"ag-Grid: could not find data item as object was not found\", data);\n        return null;\n      }\n    }\n\n    return rowNode;\n  };\n\n  ClientSideNodeManager.prototype.recursiveFunction = function (rowData, parent, level) {\n    var _this = this; // make sure the rowData is an array and not a string of json - this was a commonly reported problem on the forum\n\n\n    if (typeof rowData === 'string') {\n      console.warn('ag-Grid: rowData must be an array, however you passed in a string. If you are loading JSON, make sure you convert the JSON string to JavaScript objects first');\n      return;\n    }\n\n    var rowNodes = [];\n    rowData.forEach(function (dataItem) {\n      var node = _this.createNode(dataItem, parent, level);\n\n      rowNodes.push(node);\n    });\n    return rowNodes;\n  };\n\n  ClientSideNodeManager.prototype.createNode = function (dataItem, parent, level) {\n    var node = new RowNode();\n    this.context.wireBean(node);\n    var doingTreeData = this.gridOptionsWrapper.isTreeData();\n\n    var doingLegacyTreeData = !doingTreeData && _.exists(this.getNodeChildDetails);\n\n    var nodeChildDetails = doingLegacyTreeData ? this.getNodeChildDetails(dataItem) : null;\n\n    if (nodeChildDetails && nodeChildDetails.group) {\n      node.group = true;\n      node.childrenAfterGroup = this.recursiveFunction(nodeChildDetails.children, node, level + 1);\n      node.expanded = nodeChildDetails.expanded === true;\n      node.field = nodeChildDetails.field;\n      node.key = nodeChildDetails.key;\n      /** @deprecated is now 'master' */\n\n      node.canFlower = node.master; // pull out all the leaf children and add to our node\n\n      this.setLeafChildren(node);\n    } else {\n      node.group = false;\n\n      if (doingTreeData) {\n        node.master = false;\n        node.expanded = false;\n      } else {\n        // this is the default, for when doing grid data\n        if (this.doesDataFlower) {\n          node.master = this.doesDataFlower(dataItem);\n        } else if (this.doingMasterDetail) {\n          // if we are doing master detail, then the\n          // default is that everything can flower.\n          if (this.isRowMasterFunc) {\n            node.master = this.isRowMasterFunc(dataItem);\n          } else {\n            node.master = true;\n          }\n        } else {\n          node.master = false;\n        }\n\n        var rowGroupColumns = this.columnController.getRowGroupColumns();\n        var numRowGroupColumns = rowGroupColumns ? rowGroupColumns.length : 0; // need to take row group into account when determining level\n\n        var masterRowLevel = level + numRowGroupColumns;\n        node.expanded = node.master ? this.isExpanded(masterRowLevel) : false;\n      }\n    } // support for backwards compatibility, canFlow is now called 'master'\n\n\n    node.canFlower = node.master;\n\n    if (parent && !this.suppressParentsInRowNodes) {\n      node.parent = parent;\n    }\n\n    node.level = level;\n    node.setDataAndId(dataItem, this.nextId.toString());\n\n    if (this.allNodesMap[node.id]) {\n      console.warn(\"ag-grid: duplicate node id '\" + node.id + \"' detected from getRowNodeId callback, this could cause issues in your grid.\");\n    }\n\n    this.allNodesMap[node.id] = node;\n    this.nextId++;\n    return node;\n  };\n\n  ClientSideNodeManager.prototype.isExpanded = function (level) {\n    var expandByDefault = this.gridOptionsWrapper.getGroupDefaultExpanded();\n\n    if (expandByDefault === -1) {\n      return true;\n    } else {\n      return level < expandByDefault;\n    }\n  }; // this is only used for doing legacy tree data\n\n\n  ClientSideNodeManager.prototype.setLeafChildren = function (node) {\n    node.allLeafChildren = [];\n\n    if (node.childrenAfterGroup) {\n      node.childrenAfterGroup.forEach(function (childAfterGroup) {\n        if (childAfterGroup.group) {\n          if (childAfterGroup.allLeafChildren) {\n            childAfterGroup.allLeafChildren.forEach(function (leafChild) {\n              return node.allLeafChildren.push(leafChild);\n            });\n          }\n        } else {\n          node.allLeafChildren.push(childAfterGroup);\n        }\n      });\n    }\n  };\n\n  ClientSideNodeManager.prototype.isLegacyTreeData = function () {\n    var rowsAlreadyGrouped = _.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());\n\n    if (rowsAlreadyGrouped) {\n      console.warn('ag-Grid: adding and removing rows is not supported when using nodeChildDetailsFunc, ie it is not ' + 'supported for legacy tree data. Please see the docs on the new preferred way of providing tree data that works with delta updates.');\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  ClientSideNodeManager.TOP_LEVEL = 0;\n  ClientSideNodeManager.ROOT_NODE_ID = 'ROOT_NODE_ID';\n  return ClientSideNodeManager;\n}();\n\nexport { ClientSideNodeManager };","map":null,"metadata":{},"sourceType":"module"}
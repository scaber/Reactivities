{"ast":null,"code":"'use strict';\n\nvar support = require('./support');\n\nvar utils = require('./utils');\n\nvar crc32 = require('./crc32');\n\nvar signature = require('./signature');\n\nvar defaults = require('./defaults');\n\nvar base64 = require('./base64');\n\nvar compressions = require('./compressions');\n\nvar CompressedObject = require('./compressedObject');\n\nvar nodeBuffer = require('./nodeBuffer');\n\nvar utf8 = require('./utf8');\n\nvar StringWriter = require('./stringWriter');\n\nvar Uint8ArrayWriter = require('./uint8ArrayWriter');\n/**\n * Returns the raw data of a ZipObject, decompress the content if necessary.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\n\n\nvar getRawData = function (file) {\n  if (file._data instanceof CompressedObject) {\n    file._data = file._data.getContent();\n    file.options.binary = true;\n    file.options.base64 = false;\n\n    if (utils.getTypeOf(file._data) === \"uint8array\") {\n      var copy = file._data; // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.\n      // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).\n\n      file._data = new Uint8Array(copy.length); // with an empty Uint8Array, Opera fails with a \"Offset larger than array size\"\n\n      if (copy.length !== 0) {\n        file._data.set(copy, 0);\n      }\n    }\n  }\n\n  return file._data;\n};\n/**\n * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\n\n\nvar getBinaryData = function (file) {\n  var result = getRawData(file),\n      type = utils.getTypeOf(result);\n\n  if (type === \"string\") {\n    if (!file.options.binary) {\n      // unicode text !\n      // unicode string => binary string is a painful process, check if we can avoid it.\n      if (support.nodebuffer) {\n        return nodeBuffer(result, \"utf-8\");\n      }\n    }\n\n    return file.asBinary();\n  }\n\n  return result;\n};\n/**\n * Transform this._data into a string.\n * @param {function} filter a function String -> String, applied if not null on the result.\n * @return {String} the string representing this._data.\n */\n\n\nvar dataToString = function (asUTF8) {\n  var result = getRawData(this);\n\n  if (result === null || typeof result === \"undefined\") {\n    return \"\";\n  } // if the data is a base64 string, we decode it before checking the encoding !\n\n\n  if (this.options.base64) {\n    result = base64.decode(result);\n  }\n\n  if (asUTF8 && this.options.binary) {\n    // JSZip.prototype.utf8decode supports arrays as input\n    // skip to array => string step, utf8decode will do it.\n    result = out.utf8decode(result);\n  } else {\n    // no utf8 transformation, do the array => string step.\n    result = utils.transformTo(\"string\", result);\n  }\n\n  if (!asUTF8 && !this.options.binary) {\n    result = utils.transformTo(\"string\", out.utf8encode(result));\n  }\n\n  return result;\n};\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\n\n\nvar ZipObject = function (name, data, options) {\n  this.name = name;\n  this.dir = options.dir;\n  this.date = options.date;\n  this.comment = options.comment;\n  this.unixPermissions = options.unixPermissions;\n  this.dosPermissions = options.dosPermissions;\n  this._data = data;\n  this.options = options;\n  /*\n   * This object contains initial values for dir and date.\n   * With them, we can check if the user changed the deprecated metadata in\n   * `ZipObject#options` or not.\n   */\n\n  this._initialMetadata = {\n    dir: options.dir,\n    date: options.date\n  };\n};\n\nZipObject.prototype = {\n  /**\n   * Return the content as UTF8 string.\n   * @return {string} the UTF8 string.\n   */\n  asText: function () {\n    return dataToString.call(this, true);\n  },\n\n  /**\n   * Returns the binary content.\n   * @return {string} the content as binary.\n   */\n  asBinary: function () {\n    return dataToString.call(this, false);\n  },\n\n  /**\n   * Returns the content as a nodejs Buffer.\n   * @return {Buffer} the content as a Buffer.\n   */\n  asNodeBuffer: function () {\n    var result = getBinaryData(this);\n    return utils.transformTo(\"nodebuffer\", result);\n  },\n\n  /**\n   * Returns the content as an Uint8Array.\n   * @return {Uint8Array} the content as an Uint8Array.\n   */\n  asUint8Array: function () {\n    var result = getBinaryData(this);\n    return utils.transformTo(\"uint8array\", result);\n  },\n\n  /**\n   * Returns the content as an ArrayBuffer.\n   * @return {ArrayBuffer} the content as an ArrayBufer.\n   */\n  asArrayBuffer: function () {\n    return this.asUint8Array().buffer;\n  }\n};\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\n\nvar decToHex = function (dec, bytes) {\n  var hex = \"\",\n      i;\n\n  for (i = 0; i < bytes; i++) {\n    hex += String.fromCharCode(dec & 0xff);\n    dec = dec >>> 8;\n  }\n\n  return hex;\n};\n/**\n * Transforms the (incomplete) options from the user into the complete\n * set of options to create a file.\n * @private\n * @param {Object} o the options from the user.\n * @return {Object} the complete set of options.\n */\n\n\nvar prepareFileAttrs = function (o) {\n  o = o || {};\n\n  if (o.base64 === true && (o.binary === null || o.binary === undefined)) {\n    o.binary = true;\n  }\n\n  o = utils.extend(o, defaults);\n  o.date = o.date || new Date();\n  if (o.compression !== null) o.compression = o.compression.toUpperCase();\n  return o;\n};\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} o the options of the file\n * @return {Object} the new file.\n */\n\n\nvar fileAdd = function (name, data, o) {\n  // be sure sub folders exist\n  var dataType = utils.getTypeOf(data),\n      parent;\n  o = prepareFileAttrs(o);\n\n  if (typeof o.unixPermissions === \"string\") {\n    o.unixPermissions = parseInt(o.unixPermissions, 8);\n  } // UNX_IFDIR  0040000 see zipinfo.c\n\n\n  if (o.unixPermissions && o.unixPermissions & 0x4000) {\n    o.dir = true;\n  } // Bit 4    Directory\n\n\n  if (o.dosPermissions && o.dosPermissions & 0x0010) {\n    o.dir = true;\n  }\n\n  if (o.dir) {\n    name = forceTrailingSlash(name);\n  }\n\n  if (o.createFolders && (parent = parentFolder(name))) {\n    folderAdd.call(this, parent, true);\n  }\n\n  if (o.dir || data === null || typeof data === \"undefined\") {\n    o.base64 = false;\n    o.binary = false;\n    data = null;\n    dataType = null;\n  } else if (dataType === \"string\") {\n    if (o.binary && !o.base64) {\n      // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask\n      if (o.optimizedBinaryString !== true) {\n        // this is a string, not in a base64 format.\n        // Be sure that this is a correct \"binary string\"\n        data = utils.string2binary(data);\n      }\n    }\n  } else {\n    // arraybuffer, uint8array, ...\n    o.base64 = false;\n    o.binary = true;\n\n    if (!dataType && !(data instanceof CompressedObject)) {\n      throw new Error(\"The data of '\" + name + \"' is in an unsupported format !\");\n    } // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n\n\n    if (dataType === \"arraybuffer\") {\n      data = utils.transformTo(\"uint8array\", data);\n    }\n  }\n\n  var object = new ZipObject(name, data, o);\n  this.files[name] = object;\n  return object;\n};\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\n\n\nvar parentFolder = function (path) {\n  if (path.slice(-1) == '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  var lastSlash = path.lastIndexOf('/');\n  return lastSlash > 0 ? path.substring(0, lastSlash) : \"\";\n};\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\n\n\nvar forceTrailingSlash = function (path) {\n  // Check the name ends with a /\n  if (path.slice(-1) != \"/\") {\n    path += \"/\"; // IE doesn't like substr(-1)\n  }\n\n  return path;\n};\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\n\n\nvar folderAdd = function (name, createFolders) {\n  createFolders = typeof createFolders !== 'undefined' ? createFolders : false;\n  name = forceTrailingSlash(name); // Does this folder already exist?\n\n  if (!this.files[name]) {\n    fileAdd.call(this, name, null, {\n      dir: true,\n      createFolders: createFolders\n    });\n  }\n\n  return this.files[name];\n};\n/**\n * Generate a JSZip.CompressedObject for a given zipOject.\n * @param {ZipObject} file the object to read.\n * @param {JSZip.compression} compression the compression to use.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {JSZip.CompressedObject} the compressed result.\n */\n\n\nvar generateCompressedObjectFrom = function (file, compression, compressionOptions) {\n  var result = new CompressedObject(),\n      content; // the data has not been decompressed, we might reuse things !\n\n  if (file._data instanceof CompressedObject) {\n    result.uncompressedSize = file._data.uncompressedSize;\n    result.crc32 = file._data.crc32;\n\n    if (result.uncompressedSize === 0 || file.dir) {\n      compression = compressions['STORE'];\n      result.compressedContent = \"\";\n      result.crc32 = 0;\n    } else if (file._data.compressionMethod === compression.magic) {\n      result.compressedContent = file._data.getCompressedContent();\n    } else {\n      content = file._data.getContent(); // need to decompress / recompress\n\n      result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n    }\n  } else {\n    // have uncompressed data\n    content = getBinaryData(file);\n\n    if (!content || content.length === 0 || file.dir) {\n      compression = compressions['STORE'];\n      content = \"\";\n    }\n\n    result.uncompressedSize = content.length;\n    result.crc32 = crc32(content);\n    result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n  }\n\n  result.compressedSize = result.compressedContent.length;\n  result.compressionMethod = compression.magic;\n  return result;\n};\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\n\n\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n  var result = unixPermissions;\n\n  if (!unixPermissions) {\n    // I can't use octal values in strict mode, hence the hexa.\n    //  040775 => 0x41fd\n    // 0100664 => 0x81b4\n    result = isDir ? 0x41fd : 0x81b4;\n  }\n\n  return (result & 0xFFFF) << 16;\n};\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\n\n\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n  // the dir flag is already set for compatibility\n  return (dosPermissions || 0) & 0x3F;\n};\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {string} name the file name.\n * @param {ZipObject} file the file content.\n * @param {JSZip.CompressedObject} compressedObject the compressed object.\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {object} the zip parts.\n */\n\n\nvar generateZipParts = function (name, file, compressedObject, offset, platform, encodeFileName) {\n  var data = compressedObject.compressedContent,\n      useCustomEncoding = encodeFileName !== utf8.utf8encode,\n      encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n      utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n      comment = file.comment || \"\",\n      encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n      utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n      useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n      useUTF8ForComment = utfEncodedComment.length !== comment.length,\n      o = file.options,\n      dosTime,\n      dosDate,\n      extraFields = \"\",\n      unicodePathExtraField = \"\",\n      unicodeCommentExtraField = \"\",\n      dir,\n      date; // handle the deprecated options.dir\n\n  if (file._initialMetadata.dir !== file.dir) {\n    dir = file.dir;\n  } else {\n    dir = o.dir;\n  } // handle the deprecated options.date\n\n\n  if (file._initialMetadata.date !== file.date) {\n    date = file.date;\n  } else {\n    date = o.date;\n  }\n\n  var extFileAttr = 0;\n  var versionMadeBy = 0;\n\n  if (dir) {\n    // dos or unix, we set the dos dir flag\n    extFileAttr |= 0x00010;\n  }\n\n  if (platform === \"UNIX\") {\n    versionMadeBy = 0x031E; // UNIX, version 3.0\n\n    extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n  } else {\n    // DOS or other, fallback to DOS\n    versionMadeBy = 0x0014; // DOS, version 2.0\n\n    extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n  } // date\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n\n  dosTime = date.getHours();\n  dosTime = dosTime << 6;\n  dosTime = dosTime | date.getMinutes();\n  dosTime = dosTime << 5;\n  dosTime = dosTime | date.getSeconds() / 2;\n  dosDate = date.getFullYear() - 1980;\n  dosDate = dosDate << 4;\n  dosDate = dosDate | date.getMonth() + 1;\n  dosDate = dosDate << 5;\n  dosDate = dosDate | date.getDate();\n\n  if (useUTF8ForFileName) {\n    // set the unicode path extra field. unzip needs at least one extra\n    // field to correctly handle unicode path, so using the path is as good\n    // as any other information. This could improve the situation with\n    // other archive managers too.\n    // This field is usually used without the utf8 flag, with a non\n    // unicode path in the header (winrar, winzip). This helps (a bit)\n    // with the messy Windows' default compressed folders feature but\n    // breaks on p7zip which doesn't seek the unicode path extra field.\n    // So for now, UTF-8 everywhere !\n    unicodePathExtraField = // Version\n    decToHex(1, 1) + // NameCRC32\n    decToHex(crc32(encodedFileName), 4) + // UnicodeName\n    utfEncodedFileName;\n    extraFields += // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x70\" + // size\n    decToHex(unicodePathExtraField.length, 2) + // content\n    unicodePathExtraField;\n  }\n\n  if (useUTF8ForComment) {\n    unicodeCommentExtraField = // Version\n    decToHex(1, 1) + // CommentCRC32\n    decToHex(this.crc32(encodedComment), 4) + // UnicodeName\n    utfEncodedComment;\n    extraFields += // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x63\" + // size\n    decToHex(unicodeCommentExtraField.length, 2) + // content\n    unicodeCommentExtraField;\n  }\n\n  var header = \"\"; // version needed to extract\n\n  header += \"\\x0A\\x00\"; // general purpose bit flag\n  // set bit 11 if utf8\n\n  header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? \"\\x00\\x08\" : \"\\x00\\x00\"; // compression method\n\n  header += compressedObject.compressionMethod; // last mod file time\n\n  header += decToHex(dosTime, 2); // last mod file date\n\n  header += decToHex(dosDate, 2); // crc-32\n\n  header += decToHex(compressedObject.crc32, 4); // compressed size\n\n  header += decToHex(compressedObject.compressedSize, 4); // uncompressed size\n\n  header += decToHex(compressedObject.uncompressedSize, 4); // file name length\n\n  header += decToHex(encodedFileName.length, 2); // extra field length\n\n  header += decToHex(extraFields.length, 2);\n  var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n  var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)\n  decToHex(versionMadeBy, 2) + // file header (common to file and central directory)\n  header + // file comment length\n  decToHex(encodedComment.length, 2) + // disk number start\n  \"\\x00\\x00\" + // internal file attributes TODO\n  \"\\x00\\x00\" + // external file attributes\n  decToHex(extFileAttr, 4) + // relative offset of local header\n  decToHex(offset, 4) + // file name\n  encodedFileName + // extra field\n  extraFields + // file comment\n  encodedComment;\n  return {\n    fileRecord: fileRecord,\n    dirRecord: dirRecord,\n    compressedObject: compressedObject\n  };\n}; // return the actual prototype of JSZip\n\n\nvar out = {\n  /**\n   * Read an existing zip and merge the data in the current JSZip object.\n   * The implementation is in jszip-load.js, don't forget to include it.\n   * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load\n   * @param {Object} options Options for loading the stream.\n   *  options.base64 : is the stream in base64 ? default : false\n   * @return {JSZip} the current JSZip object\n   */\n  load: function (stream, options) {\n    throw new Error(\"Load method is not defined. Is the file jszip-load.js included ?\");\n  },\n\n  /**\n   * Filter nested files/folders with the specified function.\n   * @param {Function} search the predicate to use :\n   * function (relativePath, file) {...}\n   * It takes 2 arguments : the relative path and the file.\n   * @return {Array} An array of matching elements.\n   */\n  filter: function (search) {\n    var result = [],\n        filename,\n        relativePath,\n        file,\n        fileClone;\n\n    for (filename in this.files) {\n      if (!this.files.hasOwnProperty(filename)) {\n        continue;\n      }\n\n      file = this.files[filename]; // return a new object, don't let the user mess with our internal objects :)\n\n      fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));\n      relativePath = filename.slice(this.root.length, filename.length);\n\n      if (filename.slice(0, this.root.length) === this.root && // the file is in the current root\n      search(relativePath, fileClone)) {\n        // and the file matches the function\n        result.push(fileClone);\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * Add a file to the zip file, or search a file.\n   * @param   {string|RegExp} name The name of the file to add (if data is defined),\n   * the name of the file to find (if no data) or a regex to match files.\n   * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n   * @param   {Object} o     File options\n   * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n   * a file (when searching by string) or an array of files (when searching by regex).\n   */\n  file: function (name, data, o) {\n    if (arguments.length === 1) {\n      if (utils.isRegExp(name)) {\n        var regexp = name;\n        return this.filter(function (relativePath, file) {\n          return !file.dir && regexp.test(relativePath);\n        });\n      } else {\n        // text\n        return this.filter(function (relativePath, file) {\n          return !file.dir && relativePath === name;\n        })[0] || null;\n      }\n    } else {\n      // more than one argument : we have data !\n      name = this.root + name;\n      fileAdd.call(this, name, data, o);\n    }\n\n    return this;\n  },\n\n  /**\n   * Add a directory to the zip file, or search.\n   * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n   * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n   */\n  folder: function (arg) {\n    if (!arg) {\n      return this;\n    }\n\n    if (utils.isRegExp(arg)) {\n      return this.filter(function (relativePath, file) {\n        return file.dir && arg.test(relativePath);\n      });\n    } // else, name is a new folder\n\n\n    var name = this.root + arg;\n    var newFolder = folderAdd.call(this, name); // Allow chaining by returning a new object with this folder as the root\n\n    var ret = this.clone();\n    ret.root = newFolder.name;\n    return ret;\n  },\n\n  /**\n   * Delete a file, or a directory and all sub-files, from the zip\n   * @param {string} name the name of the file to delete\n   * @return {JSZip} this JSZip object\n   */\n  remove: function (name) {\n    name = this.root + name;\n    var file = this.files[name];\n\n    if (!file) {\n      // Look for any folders\n      if (name.slice(-1) != \"/\") {\n        name += \"/\";\n      }\n\n      file = this.files[name];\n    }\n\n    if (file && !file.dir) {\n      // file\n      delete this.files[name];\n    } else {\n      // maybe a folder, delete recursively\n      var kids = this.filter(function (relativePath, file) {\n        return file.name.slice(0, name.length) === name;\n      });\n\n      for (var i = 0; i < kids.length; i++) {\n        delete this.files[kids[i].name];\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Generate the complete zip file\n   * @param {Object} options the options to generate the zip file :\n   * - base64, (deprecated, use type instead) true to generate base64.\n   * - compression, \"STORE\" by default.\n   * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n   * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n   */\n  generate: function (options) {\n    options = utils.extend(options || {}, {\n      base64: true,\n      compression: \"STORE\",\n      compressionOptions: null,\n      type: \"base64\",\n      platform: \"DOS\",\n      comment: null,\n      mimeType: 'application/zip',\n      encodeFileName: utf8.utf8encode\n    });\n    utils.checkSupport(options.type); // accept nodejs `process.platform`\n\n    if (options.platform === 'darwin' || options.platform === 'freebsd' || options.platform === 'linux' || options.platform === 'sunos') {\n      options.platform = \"UNIX\";\n    }\n\n    if (options.platform === 'win32') {\n      options.platform = \"DOS\";\n    }\n\n    var zipData = [],\n        localDirLength = 0,\n        centralDirLength = 0,\n        writer,\n        i,\n        encodedComment = utils.transformTo(\"string\", options.encodeFileName(options.comment || this.comment || \"\")); // first, generate all the zip parts.\n\n    for (var name in this.files) {\n      if (!this.files.hasOwnProperty(name)) {\n        continue;\n      }\n\n      var file = this.files[name];\n      var compressionName = file.options.compression || options.compression.toUpperCase();\n      var compression = compressions[compressionName];\n\n      if (!compression) {\n        throw new Error(compressionName + \" is not a valid compression method !\");\n      }\n\n      var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n      var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);\n      var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);\n      localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n      centralDirLength += zipPart.dirRecord.length;\n      zipData.push(zipPart);\n    }\n\n    var dirEnd = \"\"; // end of central dir signature\n\n    dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk\n    \"\\x00\\x00\" + // number of the disk with the start of the central directory\n    \"\\x00\\x00\" + // total number of entries in the central directory on this disk\n    decToHex(zipData.length, 2) + // total number of entries in the central directory\n    decToHex(zipData.length, 2) + // size of the central directory   4 bytes\n    decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number\n    decToHex(localDirLength, 4) + // .ZIP file comment length\n    decToHex(encodedComment.length, 2) + // .ZIP file comment\n    encodedComment; // we have all the parts (and the total length)\n    // time to create a writer !\n\n    var typeName = options.type.toLowerCase();\n\n    if (typeName === \"uint8array\" || typeName === \"arraybuffer\" || typeName === \"blob\" || typeName === \"nodebuffer\") {\n      writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n    } else {\n      writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n    }\n\n    for (i = 0; i < zipData.length; i++) {\n      writer.append(zipData[i].fileRecord);\n      writer.append(zipData[i].compressedObject.compressedContent);\n    }\n\n    for (i = 0; i < zipData.length; i++) {\n      writer.append(zipData[i].dirRecord);\n    }\n\n    writer.append(dirEnd);\n    var zip = writer.finalize();\n\n    switch (options.type.toLowerCase()) {\n      // case \"zip is an Uint8Array\"\n      case \"uint8array\":\n      case \"arraybuffer\":\n      case \"nodebuffer\":\n        return utils.transformTo(options.type.toLowerCase(), zip);\n\n      case \"blob\":\n        return utils.arrayBuffer2Blob(utils.transformTo(\"arraybuffer\", zip), options.mimeType);\n      // case \"zip is a string\"\n\n      case \"base64\":\n        return options.base64 ? base64.encode(zip) : zip;\n\n      default:\n        // case \"string\" :\n        return zip;\n    }\n  },\n\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  crc32: function (input, crc) {\n    return crc32(input, crc);\n  },\n\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  utf8encode: function (string) {\n    return utils.transformTo(\"string\", utf8.utf8encode(string));\n  },\n\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  utf8decode: function (input) {\n    return utf8.utf8decode(input);\n  }\n};\nmodule.exports = out;","map":null,"metadata":{},"sourceType":"script"}
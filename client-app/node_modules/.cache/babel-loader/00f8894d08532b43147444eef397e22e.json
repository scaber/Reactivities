{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.MapUtil = void 0;\n\nvar _Map = _interopRequireDefault(require(\"ol/Map\"));\n\nvar _TileWMS = _interopRequireDefault(require(\"ol/source/TileWMS\"));\n\nvar _ImageWMS = _interopRequireDefault(require(\"ol/source/ImageWMS\"));\n\nvar _Group = _interopRequireDefault(require(\"ol/layer/Group\"));\n\nvar _Base = _interopRequireDefault(require(\"ol/layer/Base\"));\n\nvar _GeometryCollection = _interopRequireDefault(require(\"ol/geom/GeometryCollection\"));\n\nvar _Units = require(\"ol/proj/Units\");\n\nvar _UrlUtil = _interopRequireDefault(require(\"@terrestris/base-util/dist/UrlUtil/UrlUtil\"));\n\nvar _Logger = _interopRequireDefault(require(\"@terrestris/base-util/dist/Logger\"));\n\nvar _FeatureUtil = _interopRequireDefault(require(\"../FeatureUtil/FeatureUtil\"));\n\nvar _findIndex = _interopRequireDefault(require(\"lodash/findIndex\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Helper class for the OpenLayers map.\n *\n * @class\n */\n\n\nvar MapUtil =\n/*#__PURE__*/\nfunction () {\n  function MapUtil() {\n    _classCallCheck(this, MapUtil);\n  }\n\n  _createClass(MapUtil, null, [{\n    key: \"getInteractionsByName\",\n\n    /**\n     * Returns all interactions by the given name of a map.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name of the interaction to look for.\n     * @return {ol.interaction[]} The list of result interactions.\n     */\n    value: function getInteractionsByName(map, name) {\n      var interactionCandidates = [];\n\n      if (!(map instanceof _Map[\"default\"])) {\n        _Logger[\"default\"].debug('Input parameter map must be from type `ol.Map`.');\n\n        return interactionCandidates;\n      }\n\n      var interactions = map.getInteractions();\n      interactions.forEach(function (interaction) {\n        if (interaction.get('name') === name) {\n          interactionCandidates.push(interaction);\n        }\n      });\n      return interactionCandidates;\n    }\n    /**\n     * Returns all interactions of the given class of the passed map.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.interaction} clazz The class of the interaction to look for.\n     * @return {ol.interaction[]} The list of result interactions.\n     */\n\n  }, {\n    key: \"getInteractionsByClass\",\n    value: function getInteractionsByClass(map, clazz) {\n      var interactionCandidates = [];\n\n      if (!(map instanceof _Map[\"default\"])) {\n        _Logger[\"default\"].debug('Input parameter map must be from type `ol.Map`.');\n\n        return interactionCandidates;\n      }\n\n      var interactions = map.getInteractions();\n      interactions.forEach(function (interaction) {\n        if (interaction instanceof clazz) {\n          interactionCandidates.push(interaction);\n        }\n      });\n      return interactionCandidates;\n    }\n    /**\n     * Calculates the appropriate map resolution for a given scale in the given\n     * units.\n     *\n     * See: https://gis.stackexchange.com/questions/158435/\n     * how-to-get-current-scale-in-openlayers-3\n     *\n     * @method\n     * @param {number} scale The input scale to calculate the appropriate\n     *                       resolution for.\n     * @param {string} units The units to use for calculation (m or degrees).\n     * @return {number} The calculated resolution.\n     */\n\n  }, {\n    key: \"getResolutionForScale\",\n    value: function getResolutionForScale(scale, units) {\n      var dpi = 25.4 / 0.28;\n      var mpu = _Units.METERS_PER_UNIT[units];\n      var inchesPerMeter = 39.37;\n      return parseFloat(scale) / (mpu * inchesPerMeter * dpi);\n    }\n    /**\n     * Returns the appropriate scale for the given resolution and units.\n     *\n     * @method\n     * @param {number} resolution The resolutions to calculate the scale for.\n     * @param {string} units The units the resolution is based on, typically\n     *                       either 'm' or 'degrees'.\n     * @return {number} The appropriate scale.\n     */\n\n  }, {\n    key: \"getScaleForResolution\",\n    value: function getScaleForResolution(resolution, units) {\n      var dpi = 25.4 / 0.28;\n      var mpu = _Units.METERS_PER_UNIT[units];\n      var inchesPerMeter = 39.37;\n      return parseFloat(resolution) * mpu * inchesPerMeter * dpi;\n    }\n    /**\n     * Returns all layers of a collection. Even the hidden ones.\n     *\n     * @param {ol.Map|ol.layer.Group} collection The collection to get the layers\n     *                                           from. This can be an ol.layer.Group\n     *                                           or an ol.Map.\n     * @param {Function} [filter] A filter function that receives the layer.\n     *                            If it returns true it will be included in the\n     *                            returned layers.\n     * @return {Array} An array of all Layers.\n     */\n\n  }, {\n    key: \"getAllLayers\",\n    value: function getAllLayers(collection) {\n      var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n\n      if (!(collection instanceof _Map[\"default\"]) && !(collection instanceof _Group[\"default\"])) {\n        _Logger[\"default\"].error('Input parameter collection must be from type `ol.Map`' + 'or `ol.layer.Group`.');\n\n        return [];\n      }\n\n      var layers = collection.getLayers().getArray();\n      var allLayers = [];\n      layers.forEach(function (layer) {\n        if (layer instanceof _Group[\"default\"]) {\n          MapUtil.getAllLayers(layer).forEach(function (layeri) {\n            if (filter(layeri)) {\n              allLayers.push(layeri);\n            }\n          });\n        }\n\n        if (filter(layer)) {\n          allLayers.push(layer);\n        }\n      });\n      return allLayers;\n    }\n    /**\n     * Get a layer by its key (ol_uid).\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} ol_uid The ol_uid of a layer.\n     * @return {ol.layer.Layer} The layer.\n     */\n\n  }, {\n    key: \"getLayerByName\",\n\n    /**\n     * Returns the layer from the provided map by the given name.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name to get the layer by.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n    value: function getLayerByName(map, name) {\n      var layers = MapUtil.getAllLayers(map);\n      return layers.filter(function (layer) {\n        return layer.get('name') === name;\n      })[0];\n    }\n    /**\n     * Returns the layer from the provided map by the given name\n     * (parameter LAYERS).\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name to get the layer by.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n\n  }, {\n    key: \"getLayerByNameParam\",\n    value: function getLayerByNameParam(map, name) {\n      var layers = MapUtil.getAllLayers(map);\n      var layerCandidate;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var layer = _step.value;\n\n          if (layer.getSource && layer.getSource().getParams && layer.getSource().getParams()['LAYERS'] === name) {\n            layerCandidate = layer;\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return layerCandidate;\n    }\n    /**\n     * Returns the layer from the provided map by the given feature.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.Feature} feature The feature to get the layer by.\n     * @param {Array} namespaces list of supported GeoServer namespaces.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n\n  }, {\n    key: \"getLayerByFeature\",\n    value: function getLayerByFeature(map, feature, namespaces) {\n      var featureTypeName = _FeatureUtil[\"default\"].getFeatureTypeName(feature);\n\n      var layerCandidate;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = namespaces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var namespace = _step2.value;\n          var qualifiedFeatureTypeName = \"\".concat(namespace, \":\").concat(featureTypeName);\n          var layer = MapUtil.getLayerByNameParam(map, qualifiedFeatureTypeName);\n\n          if (layer) {\n            layerCandidate = layer;\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return layerCandidate;\n    }\n    /**\n     * Returns all layers of the specified layer group recursively.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.Layer.Group} layerGroup The group to flatten.\n     * @return {Array} The (flattened) layers from the group\n     */\n\n  }, {\n    key: \"getLayersByGroup\",\n    value: function getLayersByGroup(map, layerGroup) {\n      var layerCandidates = [];\n      layerGroup.getLayers().forEach(function (layer) {\n        if (layer instanceof _Group[\"default\"]) {\n          layerCandidates.push.apply(layerCandidates, _toConsumableArray(MapUtil.getLayersByGroup(map, layer)));\n        } else {\n          layerCandidates.push(layer);\n        }\n      });\n      return layerCandidates;\n    }\n    /**\n     * Returns the list of layers matching the given pair of properties.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} key The property key.\n     * @param {Object} value The property value.\n     *\n     * @return {ol.layer.Base[]} The array of matching layers.\n     */\n\n  }, {\n    key: \"getLayersByProperty\",\n    value: function getLayersByProperty(map, key, value) {\n      if (!map || !key) {\n        return;\n      }\n\n      var mapLayers = MapUtil.getAllLayers(map);\n      return mapLayers.filter(function (l) {\n        return l.get(key) === value;\n      });\n    }\n    /**\n     * Get information about the LayerPosition in the tree.\n     *\n     * @param {ol.layer.Layer} layer The layer to get the information.\n     * @param {ol.layer.Group|ol.Map} [groupLayerOrMap] The groupLayer or map\n     *                                                  containing the layer.\n     * @return {Object} An object with these keys:\n     *    {ol.layer.Group} groupLayer The groupLayer containing the layer.\n     *    {Integer} position The position of the layer in the collection.\n     */\n\n  }, {\n    key: \"getLayerPositionInfo\",\n    value: function getLayerPositionInfo(layer, groupLayerOrMap) {\n      var groupLayer = groupLayerOrMap instanceof _Group[\"default\"] ? groupLayerOrMap : groupLayerOrMap.getLayerGroup();\n      var layers = groupLayer.getLayers().getArray();\n      var info = {};\n\n      if (layers.indexOf(layer) < 0) {\n        layers.forEach(function (childLayer) {\n          if (childLayer instanceof _Group[\"default\"] && !info.groupLayer) {\n            info = MapUtil.getLayerPositionInfo(layer, childLayer);\n          }\n        });\n      } else {\n        info.position = layers.indexOf(layer);\n        info.groupLayer = groupLayer;\n      }\n\n      return info;\n    }\n    /**\n     * Get the getlegendGraphic url of a layer. Designed for geoserver.\n     * Currently supported Sources:\n     *  - ol.source.TileWms (with url configured)\n     *  - ol.source.ImageWms (with url configured)\n     *\n     * @param {ol.layer.Layer} layer The layer that you want to have a legendUrlfor.\n     * @return {string|undefined} The getLegendGraphicUrl.\n     */\n\n  }, {\n    key: \"getLegendGraphicUrl\",\n    value: function getLegendGraphicUrl(layer, extraParams) {\n      if (!layer) {\n        _Logger[\"default\"].error('No layer passed to MapUtil.getLegendGraphicUrl.');\n\n        return;\n      }\n\n      var source = layer.getSource();\n\n      if (!(layer instanceof _Base[\"default\"]) || !source) {\n        _Logger[\"default\"].error('Invalid layer passed to MapUtil.getLegendGraphicUrl.');\n\n        return;\n      }\n\n      var isTiledWMS = source instanceof _TileWMS[\"default\"];\n      var isImageWMS = source instanceof _ImageWMS[\"default\"];\n\n      if (isTiledWMS || isImageWMS) {\n        var _source = layer.getSource();\n\n        var url = isTiledWMS ? _source.getUrls() ? _source.getUrls()[0] : '' : _source.getUrl();\n        var params = {\n          LAYER: _source.getParams().LAYERS,\n          VERSION: '1.3.0',\n          SERVICE: 'WMS',\n          REQUEST: 'getLegendGraphic',\n          FORMAT: 'image/png'\n        };\n\n        var queryString = _UrlUtil[\"default\"].objectToRequestString(Object.assign(params, extraParams));\n\n        return /\\?/.test(url) ? \"\".concat(url, \"&\").concat(queryString) : \"\".concat(url, \"?\").concat(queryString);\n      } else {\n        _Logger[\"default\"].warn(\"Source of \\\"\".concat(layer.get('name'), \"\\\" is currently not supported \") + \"by MapUtil.getLegendGraphicUrl.\");\n\n        return;\n      }\n    }\n    /**\n     * Checks whether the resolution of the passed map's view lies inside of the\n     * min- and max-resolution of the passed layer, e.g. whether the layer should\n     * be displayed at the current map view resolution.\n     *\n     * @param {ol.layer.Layer} layer The layer to check.\n     * @param {ol.Map} map The map to get the view resolution for comparison\n     *     from.\n     * @return {boolean} Whether the resolution of the passed map's view lies\n     *     inside of the min- and max-resolution of the passed layer, e.g. whether\n     *     the layer should be displayed at the current map view resolution. Will\n     *     be `false` when no `layer` or no `map` is passed or if the view of the\n     *     map is falsy or does not have a resolution (yet).\n     */\n\n  }, {\n    key: \"layerInResolutionRange\",\n    value: function layerInResolutionRange(layer, map) {\n      var mapView = map && map.getView();\n      var currentRes = mapView && mapView.getResolution();\n\n      if (!layer || !mapView || !currentRes) {\n        // It is questionable what we should return in this case, I opted for\n        // false, since we cannot sanely determine a correct answer.\n        return false;\n      }\n\n      var layerMinRes = layer.getMinResolution(); // default: 0 if unset\n\n      var layerMaxRes = layer.getMaxResolution(); // default: Infinity if unset\n      // minimum resolution is inclusive, maximum resolution exclusive\n\n      var within = currentRes >= layerMinRes && currentRes < layerMaxRes;\n      return within;\n    }\n    /**\n     * Rounds a scalenumber in dependency to its size.\n     *\n     * @param  {number} scale The exact scale\n     * @return {number} The roundedScale\n     */\n\n  }, {\n    key: \"roundScale\",\n    value: function roundScale(scale) {\n      var roundScale;\n\n      if (scale < 100) {\n        roundScale = Math.round(scale, 10);\n      }\n\n      if (scale >= 100 && scale < 10000) {\n        roundScale = Math.round(scale / 10) * 10;\n      }\n\n      if (scale >= 10000 && scale < 1000000) {\n        roundScale = Math.round(scale / 100) * 100;\n      }\n\n      if (scale >= 1000000) {\n        roundScale = Math.round(scale / 1000) * 1000;\n      }\n\n      return roundScale;\n    }\n    /**\n     * Returns the appropriate zoom level for the given scale and units.\n      * @method\n     * @param {number} scale Map scale to get the zoom for.\n     * @param {Array} resolutions Resolutions array.\n     * @param {string} units The units the resolutions are based on, typically\n     *                       either 'm' or 'degrees'. Default is 'm'.\n     *\n     * @return {number} Determined zoom level for the given scale.\n     */\n\n  }, {\n    key: \"getZoomForScale\",\n    value: function getZoomForScale(scale, resolutions) {\n      var units = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'm';\n\n      if (Number.isNaN(Number(scale))) {\n        return 0;\n      }\n\n      if (scale < 0) {\n        return 0;\n      }\n\n      var calculatedResolution = MapUtil.getResolutionForScale(scale, units);\n      var closestVal = resolutions.reduce(function (prev, curr) {\n        var res = Math.abs(curr - calculatedResolution) < Math.abs(prev - calculatedResolution) ? curr : prev;\n        return res;\n      });\n      var zoom = (0, _findIndex[\"default\"])(resolutions, function (o) {\n        return Math.abs(o - closestVal) <= 1e-10;\n      });\n      return zoom;\n    }\n    /**\n     * Fits the map's view to the extent of the passed features.\n     *\n     * @param {ol.Map} map The map to get the view from.\n     * @param {ol.Feature[]} features The features to zoom to.\n     */\n\n  }, {\n    key: \"zoomToFeatures\",\n    value: function zoomToFeatures(map, features) {\n      if (!(map instanceof _Map[\"default\"])) {\n        return;\n      }\n\n      var featGeometries = [];\n      features.forEach(function (feature) {\n        if (feature.getGeometry() !== null) {\n          featGeometries.push(feature.getGeometry());\n        }\n      });\n\n      if (featGeometries.length > 0) {\n        var geomCollection = new _GeometryCollection[\"default\"](featGeometries);\n        map.getView().fit(geomCollection.getExtent());\n      }\n    }\n    /**\n     * Checks if the given layer is visible for the given resolution.\n     *\n     * @param {ol.layer.Base} layer The layer.\n     * @param {number} resolution The resolution of the map\n     */\n\n  }, {\n    key: \"isInScaleRange\",\n    value: function isInScaleRange(layer, resolution) {\n      return resolution >= layer.get('minResolution') && resolution < layer.get('maxResolution');\n    }\n  }]);\n\n  return MapUtil;\n}();\n\nexports.MapUtil = MapUtil;\n\n_defineProperty(MapUtil, \"getLayerByOlUid\", function (map, ol_uid) {\n  var layers = MapUtil.getAllLayers(map);\n  var layer = layers.find(function (l) {\n    return ol_uid === l.ol_uid.toString();\n  });\n  return layer;\n});\n\nvar _default = MapUtil;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}
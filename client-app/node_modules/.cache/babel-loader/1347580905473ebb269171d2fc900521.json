{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v22.1.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Bean, PreDestroy, Autowired, PostConstruct } from \"../context/context\";\nimport { Events } from \"../events\";\nimport { _ } from \"../utils\";\n/** Adds drag listening onto an element. In ag-Grid this is used twice, first is resizing columns,\n * second is moving the columns and column groups around (ie the 'drag' part of Drag and Drop. */\n\nvar DragService =\n/** @class */\nfunction () {\n  function DragService() {\n    this.onMouseUpListener = this.onMouseUp.bind(this);\n    this.onMouseMoveListener = this.onMouseMove.bind(this);\n    this.onTouchEndListener = this.onTouchUp.bind(this);\n    this.onTouchMoveListener = this.onTouchMove.bind(this);\n    this.dragEndFunctions = [];\n    this.dragSources = [];\n  }\n\n  DragService.prototype.init = function () {\n    this.logger = this.loggerFactory.create('DragService');\n  };\n\n  DragService.prototype.destroy = function () {\n    this.dragSources.forEach(this.removeListener.bind(this));\n    this.dragSources.length = 0;\n  };\n\n  DragService.prototype.removeListener = function (dragSourceAndListener) {\n    var element = dragSourceAndListener.dragSource.eElement;\n    var mouseDownListener = dragSourceAndListener.mouseDownListener;\n    element.removeEventListener('mousedown', mouseDownListener); // remove touch listener only if it exists\n\n    if (dragSourceAndListener.touchEnabled) {\n      var touchStartListener = dragSourceAndListener.touchStartListener;\n      element.removeEventListener('touchstart', touchStartListener, {\n        passive: true\n      });\n    }\n  };\n\n  DragService.prototype.removeDragSource = function (params) {\n    var dragSourceAndListener = _.find(this.dragSources, function (item) {\n      return item.dragSource === params;\n    });\n\n    if (!dragSourceAndListener) {\n      return;\n    }\n\n    this.removeListener(dragSourceAndListener);\n\n    _.removeFromArray(this.dragSources, dragSourceAndListener);\n  };\n\n  DragService.prototype.setNoSelectToBody = function (noSelect) {\n    var eDocument = this.gridOptionsWrapper.getDocument();\n    var eBody = eDocument.querySelector('body');\n\n    if (_.exists(eBody)) {\n      // when we drag the mouse in ag-Grid, this class gets added / removed from the body, so that\n      // the mouse isn't selecting text when dragging.\n      _.addOrRemoveCssClass(eBody, 'ag-unselectable', noSelect);\n    }\n  };\n\n  DragService.prototype.addDragSource = function (params, includeTouch) {\n    if (includeTouch === void 0) {\n      includeTouch = false;\n    }\n\n    var mouseListener = this.onMouseDown.bind(this, params);\n    params.eElement.addEventListener('mousedown', mouseListener);\n    var touchListener = null;\n    var suppressTouch = this.gridOptionsWrapper.isSuppressTouch();\n\n    if (includeTouch && !suppressTouch) {\n      touchListener = this.onTouchStart.bind(this, params);\n      params.eElement.addEventListener('touchstart', touchListener, {\n        passive: false\n      });\n    }\n\n    this.dragSources.push({\n      dragSource: params,\n      mouseDownListener: mouseListener,\n      touchStartListener: touchListener,\n      touchEnabled: includeTouch\n    });\n  }; // gets called whenever mouse down on any drag source\n\n\n  DragService.prototype.onTouchStart = function (params, touchEvent) {\n    var _this = this;\n\n    this.currentDragParams = params;\n    this.dragging = false;\n    var touch = touchEvent.touches[0];\n    this.touchLastTime = touch;\n    this.touchStart = touch;\n    touchEvent.preventDefault(); // we temporally add these listeners, for the duration of the drag, they\n    // are removed in touch end handling.\n\n    params.eElement.addEventListener('touchmove', this.onTouchMoveListener, {\n      passive: true\n    });\n    params.eElement.addEventListener('touchend', this.onTouchEndListener, {\n      passive: true\n    });\n    params.eElement.addEventListener('touchcancel', this.onTouchEndListener, {\n      passive: true\n    });\n    this.dragEndFunctions.push(function () {\n      params.eElement.removeEventListener('touchmove', _this.onTouchMoveListener, {\n        passive: true\n      });\n      params.eElement.removeEventListener('touchend', _this.onTouchEndListener, {\n        passive: true\n      });\n      params.eElement.removeEventListener('touchcancel', _this.onTouchEndListener, {\n        passive: true\n      });\n    }); // see if we want to start dragging straight away\n\n    if (params.dragStartPixels === 0) {\n      this.onCommonMove(touch, this.touchStart);\n    }\n  }; // gets called whenever mouse down on any drag source\n\n\n  DragService.prototype.onMouseDown = function (params, mouseEvent) {\n    var _this = this; // we ignore when shift key is pressed. this is for the range selection, as when\n    // user shift-clicks a cell, this should not be interpreted as the start of a drag.\n    // if (mouseEvent.shiftKey) { return; }\n\n\n    if (params.skipMouseEvent) {\n      if (params.skipMouseEvent(mouseEvent)) {\n        return;\n      }\n    } // if there are two elements with parent / child relationship, and both are draggable,\n    // when we drag the child, we should NOT drag the parent. an example of this is row moving\n    // and range selection - row moving should get preference when use drags the rowDrag component.\n\n\n    if (mouseEvent._alreadyProcessedByDragService) {\n      return;\n    }\n\n    mouseEvent._alreadyProcessedByDragService = true; // only interested in left button clicks\n\n    if (mouseEvent.button !== 0) {\n      return;\n    }\n\n    this.currentDragParams = params;\n    this.dragging = false;\n    this.mouseStartEvent = mouseEvent;\n    var eDocument = this.gridOptionsWrapper.getDocument();\n    this.setNoSelectToBody(true); // we temporally add these listeners, for the duration of the drag, they\n    // are removed in mouseup handling.\n\n    eDocument.addEventListener('mousemove', this.onMouseMoveListener);\n    eDocument.addEventListener('mouseup', this.onMouseUpListener);\n    this.dragEndFunctions.push(function () {\n      eDocument.removeEventListener('mousemove', _this.onMouseMoveListener);\n      eDocument.removeEventListener('mouseup', _this.onMouseUpListener);\n    }); //see if we want to start dragging straight away\n\n    if (params.dragStartPixels === 0) {\n      this.onMouseMove(mouseEvent);\n    }\n  }; // returns true if the event is close to the original event by X pixels either vertically or horizontally.\n  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.\n\n\n  DragService.prototype.isEventNearStartEvent = function (currentEvent, startEvent) {\n    // by default, we wait 4 pixels before starting the drag\n    var dragStartPixels = this.currentDragParams.dragStartPixels;\n    var requiredPixelDiff = _.exists(dragStartPixels) ? dragStartPixels : 4;\n    return _.areEventsNear(currentEvent, startEvent, requiredPixelDiff);\n  };\n\n  DragService.prototype.getFirstActiveTouch = function (touchList) {\n    for (var i = 0; i < touchList.length; i++) {\n      if (touchList[i].identifier === this.touchStart.identifier) {\n        return touchList[i];\n      }\n    }\n\n    return null;\n  };\n\n  DragService.prototype.onCommonMove = function (currentEvent, startEvent) {\n    if (!this.dragging) {\n      // if mouse hasn't travelled from the start position enough, do nothing\n      if (!this.dragging && this.isEventNearStartEvent(currentEvent, startEvent)) {\n        return;\n      }\n\n      this.dragging = true;\n      var event_1 = {\n        type: Events.EVENT_DRAG_STARTED,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_1);\n      this.currentDragParams.onDragStart(startEvent);\n    }\n\n    this.currentDragParams.onDragging(currentEvent);\n  };\n\n  DragService.prototype.onTouchMove = function (touchEvent) {\n    var touch = this.getFirstActiveTouch(touchEvent.touches);\n\n    if (!touch) {\n      return;\n    } // this.___statusPanel.setInfoText(Math.random() + ' onTouchMove preventDefault stopPropagation');\n    // if we don't preview default, then the browser will try and do it's own touch stuff,\n    // like do 'back button' (chrome does this) or scroll the page (eg drag column could  be confused\n    // with scroll page in the app)\n    // touchEvent.preventDefault();\n\n\n    this.onCommonMove(touch, this.touchStart);\n  }; // only gets called after a mouse down - as this is only added after mouseDown\n  // and is removed when mouseUp happens\n\n\n  DragService.prototype.onMouseMove = function (mouseEvent) {\n    this.onCommonMove(mouseEvent, this.mouseStartEvent);\n  };\n\n  DragService.prototype.onTouchUp = function (touchEvent) {\n    var touch = this.getFirstActiveTouch(touchEvent.changedTouches); // i haven't worked this out yet, but there is no matching touch\n    // when we get the touch up event. to get around this, we swap in\n    // the last touch. this is a hack to 'get it working' while we\n    // figure out what's going on, why we are not getting a touch in\n    // current event.\n\n    if (!touch) {\n      touch = this.touchLastTime;\n    } // if mouse was left up before we started to move, then this is a tap.\n    // we check this before onUpCommon as onUpCommon resets the dragging\n    // let tap = !this.dragging;\n    // let tapTarget = this.currentDragParams.eElement;\n\n\n    this.onUpCommon(touch); // if tap, tell user\n    // console.log(`${Math.random()} tap = ${tap}`);\n    // if (tap) {\n    //     tapTarget.click();\n    // }\n  };\n\n  DragService.prototype.onMouseUp = function (mouseEvent) {\n    this.onUpCommon(mouseEvent);\n  };\n\n  DragService.prototype.onUpCommon = function (eventOrTouch) {\n    if (this.dragging) {\n      this.dragging = false;\n      this.currentDragParams.onDragStop(eventOrTouch);\n      var event_2 = {\n        type: Events.EVENT_DRAG_STOPPED,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_2);\n    }\n\n    this.setNoSelectToBody(false);\n    this.mouseStartEvent = null;\n    this.touchStart = null;\n    this.touchLastTime = null;\n    this.currentDragParams = null;\n    this.dragEndFunctions.forEach(function (func) {\n      return func();\n    });\n    this.dragEndFunctions.length = 0;\n  };\n\n  __decorate([Autowired('loggerFactory')], DragService.prototype, \"loggerFactory\", void 0);\n\n  __decorate([Autowired('eventService')], DragService.prototype, \"eventService\", void 0);\n\n  __decorate([Autowired('gridOptionsWrapper')], DragService.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([Autowired('columnApi')], DragService.prototype, \"columnApi\", void 0);\n\n  __decorate([Autowired('gridApi')], DragService.prototype, \"gridApi\", void 0);\n\n  __decorate([PostConstruct], DragService.prototype, \"init\", null);\n\n  __decorate([PreDestroy], DragService.prototype, \"destroy\", null);\n\n  DragService = __decorate([Bean('dragService')], DragService);\n  return DragService;\n}();\n\nexport { DragService };","map":null,"metadata":{},"sourceType":"module"}